/* verilator lint_off PINMISSING */
/* verilator lint_off CASEX */
/* verilator lint_off CASEOVERLAP */
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="HEAD_HEAD,hls_ip_2023_2,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xcvc1902-vsva2197-2MP-e-S,HLS_INPUT_CLOCK=2.500000,HLS_INPUT_ARCH=dataflow,HLS_SYN_CLOCK=2.721000,HLS_SYN_LAT=48026,HLS_SYN_TPT=48006,HLS_SYN_MEM=94,HLS_SYN_DSP=0,HLS_SYN_FF=2337,HLS_SYN_LUT=3074,HLS_VERSION=2023_2}" *)

module HEAD (
        i_stream_TDATA,
        o_stream_TDATA,
        ap_clk,
        ap_rst_n,
        i_stream_TVALID,
        i_stream_TREADY,
        o_stream_TVALID,
        o_stream_TREADY,
        ap_start,
        ap_done,
        ap_ready,
        ap_idle,
        ap_continue
);


input  [31:0] i_stream_TDATA;
output  [31:0] o_stream_TDATA;
input   ap_clk;
input   ap_rst_n;
input   i_stream_TVALID;
output   i_stream_TREADY;
output   o_stream_TVALID;
input   o_stream_TREADY;
input   ap_start;
output   ap_done;
output   ap_ready;
output   ap_idle;
input   ap_continue;

wire   [31:0] do_head_U0_o_stream_TDATA;
 reg    ap_rst_n_inv;
wire    do_head_U0_i_stream_TREADY;
wire    do_head_U0_ap_start;
wire    do_head_U0_o_stream_TVALID;
wire    do_head_U0_ap_done;
wire    do_head_U0_ap_ready;
wire    do_head_U0_ap_idle;
wire    do_head_U0_ap_continue;

HEAD_do_head do_head_U0(
    .i_stream_TDATA(i_stream_TDATA),
    .o_stream_TDATA(do_head_U0_o_stream_TDATA),
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .i_stream_TVALID(i_stream_TVALID),
    .i_stream_TREADY(do_head_U0_i_stream_TREADY),
    .ap_start(do_head_U0_ap_start),
    .o_stream_TVALID(do_head_U0_o_stream_TVALID),
    .o_stream_TREADY(o_stream_TREADY),
    .ap_done(do_head_U0_ap_done),
    .ap_ready(do_head_U0_ap_ready),
    .ap_idle(do_head_U0_ap_idle),
    .ap_continue(do_head_U0_ap_continue)
);

assign ap_done = do_head_U0_ap_done;

assign ap_idle = do_head_U0_ap_idle;

assign ap_ready = do_head_U0_ap_ready;

always @ (*) begin
    ap_rst_n_inv = ~ap_rst_n;
end

assign do_head_U0_ap_continue = ap_continue;

assign do_head_U0_ap_start = ap_start;

assign i_stream_TREADY = do_head_U0_i_stream_TREADY;

assign o_stream_TDATA = do_head_U0_o_stream_TDATA;

assign o_stream_TVALID = do_head_U0_o_stream_TVALID;

endmodule //HEAD
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_do_adapt (
        ap_clk,
        ap_rst,
        ap_start,
        start_full_n,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        ln_sm_dout,
        ln_sm_num_data_valid,
        ln_sm_fifo_cap,
        ln_sm_empty_n,
        ln_sm_read,
        adpt_sm_din,
        adpt_sm_num_data_valid,
        adpt_sm_fifo_cap,
        adpt_sm_full_n,
        adpt_sm_write,
        start_out,
        start_write
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
input   start_full_n;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input  [7:0] ln_sm_dout;
input  [2:0] ln_sm_num_data_valid;
input  [2:0] ln_sm_fifo_cap;
input   ln_sm_empty_n;
output   ln_sm_read;
output  [7:0] adpt_sm_din;
input  [2:0] adpt_sm_num_data_valid;
input  [2:0] adpt_sm_fifo_cap;
input   adpt_sm_full_n;
output   adpt_sm_write;
output   start_out;
output   start_write;

reg ap_idle;
reg ln_sm_read;
reg adpt_sm_write;
reg start_write;

reg    real_start;
reg    start_once_reg;
(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_idle_pp0;
wire    internal_ap_ready;
wire   [0:0] icmp_ln79_fu_77_p2;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg    ap_block_state2_pp0_stage0_iter1;
reg    ap_block_pp0_stage0_subdone;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    ln_sm_blk_n;
wire    ap_block_pp0_stage0;
reg    adpt_sm_blk_n;
reg   [7:0] ln_sm_read_reg_113;
reg    ap_block_pp0_stage0_11001;
reg   [7:0] cot_fu_36;
wire   [7:0] cot_4_fu_71_p2;
wire    ap_loop_init;
reg   [7:0] ap_sig_allocacmp_cot_3;
reg    ap_block_pp0_stage0_01001;
wire    ap_continue_int;
reg    ap_done_int;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
reg    ap_condition_113;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 start_once_reg = 1'b0;
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 cot_fu_36 = 8'd0;
end

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(real_start),
    .ap_ready(internal_ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin
            ap_enable_reg_pp0_iter1 <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        start_once_reg <= 1'b0;
    end else begin
        if (((real_start == 1'b1) & (internal_ap_ready == 1'b0))) begin
            start_once_reg <= 1'b1;
        end else if ((internal_ap_ready == 1'b1)) begin
            start_once_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_113)) begin
        if ((icmp_ln79_fu_77_p2 == 1'd0)) begin
            cot_fu_36 <= cot_4_fu_71_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            cot_fu_36 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ln_sm_read_reg_113 <= ln_sm_dout;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        adpt_sm_blk_n = adpt_sm_full_n;
    end else begin
        adpt_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        adpt_sm_write = 1'b1;
    end else begin
        adpt_sm_write = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (icmp_ln79_fu_77_p2 == 1'd1) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_exit_ready == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_idle_pp0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_start_int == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_cot_3 = 8'd0;
    end else begin
        ap_sig_allocacmp_cot_3 = cot_fu_36;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_done_reg == 1'b0) & (icmp_ln79_fu_77_p2 == 1'd0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ln_sm_blk_n = ln_sm_empty_n;
    end else begin
        ln_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (icmp_ln79_fu_77_p2 == 1'd0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ln_sm_read = 1'b1;
    end else begin
        ln_sm_read = 1'b0;
    end
end

always @ (*) begin
    if (((start_full_n == 1'b0) & (start_once_reg == 1'b0))) begin
        real_start = 1'b0;
    end else begin
        real_start = ap_start;
    end
end

always @ (*) begin
    if (((real_start == 1'b1) & (start_once_reg == 1'b0))) begin
        start_write = 1'b1;
    end else begin
        start_write = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign adpt_sm_din = ln_sm_read_reg_113;

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_done_reg == 1'b1) | ((icmp_ln79_fu_77_p2 == 1'd0) & (ln_sm_empty_n == 1'b0)));
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = (1'b0 == adpt_sm_full_n);
end

always @ (*) begin
    ap_condition_113 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_ready = internal_ap_ready;

assign cot_4_fu_71_p2 = (ap_sig_allocacmp_cot_3 + 8'd1);

assign icmp_ln79_fu_77_p2 = ((ap_sig_allocacmp_cot_3 == 8'd192) ? 1'b1 : 1'b0);

assign start_out = real_start;

endmodule //HEAD_do_adapt
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_do_adapt_1 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        mac_sm_dout,
        mac_sm_num_data_valid,
        mac_sm_fifo_cap,
        mac_sm_empty_n,
        mac_sm_read,
        o_stream_TREADY,
        o_stream_TDATA,
        o_stream_TVALID
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input  [75:0] mac_sm_dout;
input  [2:0] mac_sm_num_data_valid;
input  [2:0] mac_sm_fifo_cap;
input   mac_sm_empty_n;
output   mac_sm_read;
input   o_stream_TREADY;
output  [31:0] o_stream_TDATA;
output   o_stream_TVALID;

reg ap_idle;
reg mac_sm_read;

(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_enable_reg_pp0_iter2;
reg    ap_enable_reg_pp0_iter3;
reg    ap_idle_pp0;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [0:0] icmp_ln46_reg_386;
reg   [0:0] icmp_ln50_reg_390;
reg    ap_predicate_op40_read_state2;
reg    ap_block_state2_pp0_stage0_iter1;
reg   [0:0] icmp_ln46_reg_386_pp0_iter1_reg;
wire    regslice_both_o_stream_U_apdone_blk;
reg    ap_block_state3_pp0_stage0_iter2;
reg    ap_block_state3_io;
reg    ap_block_state4_pp0_stage0_iter3;
wire    ap_loop_exit_ready;
reg    ap_loop_exit_ready_pp0_iter2_reg;
reg    ap_block_pp0_stage0_subdone;
wire   [0:0] icmp_ln46_fu_178_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
reg    ap_ready_int;
reg    mac_sm_blk_n;
wire    ap_block_pp0_stage0;
reg    o_stream_TDATA_blk_n;
reg    ap_block_pp0_stage0_11001;
wire   [0:0] icmp_ln50_fu_204_p2;
reg   [0:0] icmp_ln50_reg_390_pp0_iter1_reg;
wire   [18:0] trunc_ln50_fu_242_p1;
reg    ap_condition_exit_pp0_iter2_stage0;
reg   [18:0] ap_phi_mux_empty_phi_fu_108_p4;
wire   [18:0] ap_phi_reg_pp0_iter0_empty_reg_105;
reg   [18:0] ap_phi_reg_pp0_iter1_empty_reg_105;
reg   [18:0] ap_phi_reg_pp0_iter2_empty_reg_105;
reg   [18:0] ap_phi_mux_p_0_0_0_236_phi_fu_118_p4;
wire   [18:0] ap_phi_reg_pp0_iter0_p_0_0_0_236_reg_115;
reg   [18:0] ap_phi_reg_pp0_iter1_p_0_0_0_236_reg_115;
reg   [18:0] ap_phi_reg_pp0_iter2_p_0_0_0_236_reg_115;
reg   [18:0] ap_phi_mux_p_0_0_0_134_phi_fu_127_p4;
wire   [18:0] ap_phi_reg_pp0_iter0_p_0_0_0_134_reg_124;
reg   [18:0] ap_phi_reg_pp0_iter1_p_0_0_0_134_reg_124;
reg   [18:0] ap_phi_reg_pp0_iter2_p_0_0_0_134_reg_124;
reg   [18:0] ap_phi_mux_p_0_0_032_phi_fu_136_p4;
wire   [18:0] ap_phi_reg_pp0_iter0_p_0_0_032_reg_133;
reg   [18:0] ap_phi_reg_pp0_iter1_p_0_0_032_reg_133;
reg   [18:0] ap_phi_reg_pp0_iter2_p_0_0_032_reg_133;
reg   [2:0] t_fu_72;
wire   [2:0] t_1_fu_210_p2;
wire    ap_loop_init;
reg   [2:0] ap_sig_allocacmp_t_load;
reg   [9:0] indvar_flatten_fu_76;
wire   [9:0] add_ln46_fu_172_p2;
reg   [9:0] ap_sig_allocacmp_indvar_flatten_load;
reg   [18:0] p_0_0_031_fu_80;
reg   [18:0] p_0_0_0_133_fu_84;
reg   [18:0] p_0_0_0_235_fu_88;
reg    ap_block_pp0_stage0_01001;
wire   [0:0] icmp_ln47_fu_190_p2;
wire   [2:0] select_ln46_fu_196_p3;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
wire   [31:0] o_stream_TDATA_int_regslice;
reg    o_stream_TVALID_int_regslice;
wire    o_stream_TREADY_int_regslice;
wire    regslice_both_o_stream_U_vld_out;
reg    ap_condition_167;
reg    ap_condition_165;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_enable_reg_pp0_iter2 = 1'b0;
//#0 ap_enable_reg_pp0_iter3 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 t_fu_72 = 3'd0;
//#0 indvar_flatten_fu_76 = 10'd0;
//#0 p_0_0_031_fu_80 = 19'd0;
//#0 p_0_0_0_133_fu_84 = 19'd0;
//#0 p_0_0_0_235_fu_88 = 19'd0;
end

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

HEAD_regslice_both #(
    .DataWidth( 32 ))
regslice_both_o_stream_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .data_in(o_stream_TDATA_int_regslice),
    .vld_in(o_stream_TVALID_int_regslice),
    .ack_in(o_stream_TREADY_int_regslice),
    .data_out(o_stream_TDATA),
    .vld_out(regslice_both_o_stream_U_vld_out),
    .ack_out(o_stream_TREADY),
    .apdone_blk(regslice_both_o_stream_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((ap_loop_exit_ready_pp0_iter2_reg == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter2 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter2 <= ap_enable_reg_pp0_iter1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter3 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter2_stage0)) begin
            ap_enable_reg_pp0_iter3 <= 1'b0;
        end else if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter3 <= ap_enable_reg_pp0_iter2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_167)) begin
        if (((icmp_ln50_reg_390 == 1'd1) & (icmp_ln46_reg_386 == 1'd0))) begin
            ap_phi_reg_pp0_iter2_empty_reg_105 <= {{mac_sm_dout[75:57]}};
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter2_empty_reg_105 <= ap_phi_reg_pp0_iter1_empty_reg_105;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_167)) begin
        if (((icmp_ln50_reg_390 == 1'd1) & (icmp_ln46_reg_386 == 1'd0))) begin
            ap_phi_reg_pp0_iter2_p_0_0_032_reg_133 <= trunc_ln50_fu_242_p1;
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter2_p_0_0_032_reg_133 <= ap_phi_reg_pp0_iter1_p_0_0_032_reg_133;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_167)) begin
        if (((icmp_ln50_reg_390 == 1'd1) & (icmp_ln46_reg_386 == 1'd0))) begin
            ap_phi_reg_pp0_iter2_p_0_0_0_134_reg_124 <= {{mac_sm_dout[37:19]}};
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter2_p_0_0_0_134_reg_124 <= ap_phi_reg_pp0_iter1_p_0_0_0_134_reg_124;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_167)) begin
        if (((icmp_ln50_reg_390 == 1'd1) & (icmp_ln46_reg_386 == 1'd0))) begin
            ap_phi_reg_pp0_iter2_p_0_0_0_236_reg_115 <= {{mac_sm_dout[56:38]}};
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter2_p_0_0_0_236_reg_115 <= ap_phi_reg_pp0_iter1_p_0_0_0_236_reg_115;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_165)) begin
        if ((icmp_ln46_fu_178_p2 == 1'd0)) begin
            indvar_flatten_fu_76 <= add_ln46_fu_172_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            indvar_flatten_fu_76 <= 10'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_165)) begin
        if ((icmp_ln46_fu_178_p2 == 1'd0)) begin
            t_fu_72 <= t_1_fu_210_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            t_fu_72 <= 3'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        ap_loop_exit_ready_pp0_iter2_reg <= ap_loop_exit_ready_pp0_iter1_reg;
        icmp_ln46_reg_386 <= icmp_ln46_fu_178_p2;
        icmp_ln46_reg_386_pp0_iter1_reg <= icmp_ln46_reg_386;
        icmp_ln50_reg_390 <= icmp_ln50_fu_204_p2;
        icmp_ln50_reg_390_pp0_iter1_reg <= icmp_ln50_reg_390;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_phi_reg_pp0_iter1_empty_reg_105 <= ap_phi_reg_pp0_iter0_empty_reg_105;
        ap_phi_reg_pp0_iter1_p_0_0_032_reg_133 <= ap_phi_reg_pp0_iter0_p_0_0_032_reg_133;
        ap_phi_reg_pp0_iter1_p_0_0_0_134_reg_124 <= ap_phi_reg_pp0_iter0_p_0_0_0_134_reg_124;
        ap_phi_reg_pp0_iter1_p_0_0_0_236_reg_115 <= ap_phi_reg_pp0_iter0_p_0_0_0_236_reg_115;
    end
end

always @ (posedge ap_clk) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        p_0_0_031_fu_80 <= ap_phi_mux_p_0_0_0_134_phi_fu_127_p4;
        p_0_0_0_133_fu_84 <= ap_phi_mux_p_0_0_0_236_phi_fu_118_p4;
        p_0_0_0_235_fu_88 <= ap_phi_mux_empty_phi_fu_108_p4;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (icmp_ln46_fu_178_p2 == 1'd1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd1) & (1'b0 == ap_block_pp0_stage0_subdone) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        ap_condition_exit_pp0_iter2_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter2_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_exit_ready_pp0_iter2_reg == 1'b1) & (1'b0 == ap_block_pp0_stage0_subdone))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_idle_pp0 == 1'b1) & (ap_start_int == 1'b0) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter3 == 1'b0) & (ap_enable_reg_pp0_iter2 == 1'b0) & (ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (icmp_ln50_reg_390_pp0_iter1_reg == 1'd0))) begin
        ap_phi_mux_empty_phi_fu_108_p4 = 19'd0;
    end else begin
        ap_phi_mux_empty_phi_fu_108_p4 = ap_phi_reg_pp0_iter2_empty_reg_105;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (icmp_ln50_reg_390_pp0_iter1_reg == 1'd0))) begin
        ap_phi_mux_p_0_0_032_phi_fu_136_p4 = p_0_0_031_fu_80;
    end else begin
        ap_phi_mux_p_0_0_032_phi_fu_136_p4 = ap_phi_reg_pp0_iter2_p_0_0_032_reg_133;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (icmp_ln50_reg_390_pp0_iter1_reg == 1'd0))) begin
        ap_phi_mux_p_0_0_0_134_phi_fu_127_p4 = p_0_0_0_133_fu_84;
    end else begin
        ap_phi_mux_p_0_0_0_134_phi_fu_127_p4 = ap_phi_reg_pp0_iter2_p_0_0_0_134_reg_124;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (icmp_ln50_reg_390_pp0_iter1_reg == 1'd0))) begin
        ap_phi_mux_p_0_0_0_236_phi_fu_118_p4 = p_0_0_0_235_fu_88;
    end else begin
        ap_phi_mux_p_0_0_0_236_phi_fu_118_p4 = ap_phi_reg_pp0_iter2_p_0_0_0_236_reg_115;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_indvar_flatten_load = 10'd0;
    end else begin
        ap_sig_allocacmp_indvar_flatten_load = indvar_flatten_fu_76;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_t_load = 3'd0;
    end else begin
        ap_sig_allocacmp_t_load = t_fu_72;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_predicate_op40_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        mac_sm_blk_n = mac_sm_empty_n;
    end else begin
        mac_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_predicate_op40_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        mac_sm_read = 1'b1;
    end else begin
        mac_sm_read = 1'b0;
    end
end

always @ (*) begin
    if ((((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter2 == 1'b1)) | ((1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter3 == 1'b1)))) begin
        o_stream_TDATA_blk_n = o_stream_TREADY_int_regslice;
    end else begin
        o_stream_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        o_stream_TVALID_int_regslice = 1'b1;
    end else begin
        o_stream_TVALID_int_regslice = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln46_fu_172_p2 = (ap_sig_allocacmp_indvar_flatten_load + 10'd1);

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_loop_exit_ready_pp0_iter2_reg == 1'b1) & (regslice_both_o_stream_U_apdone_blk == 1'b1)) | ((ap_enable_reg_pp0_iter3 == 1'b1) & (1'b1 == ap_block_state4_pp0_stage0_iter3)) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_loop_exit_ready_pp0_iter2_reg == 1'b1) & (regslice_both_o_stream_U_apdone_blk == 1'b1)) | ((ap_enable_reg_pp0_iter3 == 1'b1) & ((o_stream_TREADY_int_regslice == 1'b0) | (1'b1 == ap_block_state4_pp0_stage0_iter3))) | ((ap_enable_reg_pp0_iter2 == 1'b1) & ((1'b1 == ap_block_state3_io) | (1'b1 == ap_block_state3_pp0_stage0_iter2))) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_loop_exit_ready_pp0_iter2_reg == 1'b1) & (regslice_both_o_stream_U_apdone_blk == 1'b1)) | ((ap_enable_reg_pp0_iter3 == 1'b1) & ((o_stream_TREADY_int_regslice == 1'b0) | (1'b1 == ap_block_state4_pp0_stage0_iter3))) | ((ap_enable_reg_pp0_iter2 == 1'b1) & ((1'b1 == ap_block_state3_io) | (1'b1 == ap_block_state3_pp0_stage0_iter2))) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_done_reg == 1'b1);
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = ((ap_predicate_op40_read_state2 == 1'b1) & (mac_sm_empty_n == 1'b0));
end

always @ (*) begin
    ap_block_state3_io = ((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (o_stream_TREADY_int_regslice == 1'b0));
end

always @ (*) begin
    ap_block_state3_pp0_stage0_iter2 = ((regslice_both_o_stream_U_apdone_blk == 1'b1) | ((icmp_ln46_reg_386_pp0_iter1_reg == 1'd0) & (o_stream_TREADY_int_regslice == 1'b0)));
end

always @ (*) begin
    ap_block_state4_pp0_stage0_iter3 = (o_stream_TREADY_int_regslice == 1'b0);
end

always @ (*) begin
    ap_condition_165 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

always @ (*) begin
    ap_condition_167 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_phi_reg_pp0_iter0_empty_reg_105 = 'bx;

assign ap_phi_reg_pp0_iter0_p_0_0_032_reg_133 = 'bx;

assign ap_phi_reg_pp0_iter0_p_0_0_0_134_reg_124 = 'bx;

assign ap_phi_reg_pp0_iter0_p_0_0_0_236_reg_115 = 'bx;

always @ (*) begin
    ap_predicate_op40_read_state2 = ((icmp_ln50_reg_390 == 1'd1) & (icmp_ln46_reg_386 == 1'd0));
end

assign icmp_ln46_fu_178_p2 = ((ap_sig_allocacmp_indvar_flatten_load == 10'd1000) ? 1'b1 : 1'b0);

assign icmp_ln47_fu_190_p2 = ((ap_sig_allocacmp_t_load == 3'd4) ? 1'b1 : 1'b0);

assign icmp_ln50_fu_204_p2 = ((select_ln46_fu_196_p3 == 3'd0) ? 1'b1 : 1'b0);

assign o_stream_TDATA_int_regslice = ap_phi_mux_p_0_0_032_phi_fu_136_p4;

assign o_stream_TVALID = regslice_both_o_stream_U_vld_out;

assign select_ln46_fu_196_p3 = ((icmp_ln47_fu_190_p2[0:0] == 1'b1) ? 3'd0 : ap_sig_allocacmp_t_load);

assign t_1_fu_210_p2 = (select_ln46_fu_196_p3 + 3'd1);

assign trunc_ln50_fu_242_p1 = mac_sm_dout[18:0];

endmodule //HEAD_do_adapt_1
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_do_head (
        i_stream_TDATA,
        o_stream_TDATA,
        ap_clk,
        ap_rst,
        i_stream_TVALID,
        i_stream_TREADY,
        ap_start,
        o_stream_TVALID,
        o_stream_TREADY,
        ap_done,
        ap_ready,
        ap_idle,
        ap_continue
);


input  [31:0] i_stream_TDATA;
output  [31:0] o_stream_TDATA;
input   ap_clk;
input   ap_rst;
input   i_stream_TVALID;
output   i_stream_TREADY;
input   ap_start;
output   o_stream_TVALID;
input   o_stream_TREADY;
output   ap_done;
output   ap_ready;
output   ap_idle;
input   ap_continue;

wire    select_cls_U0_ap_start;
wire    select_cls_U0_ap_done;
wire    select_cls_U0_ap_continue;
wire    select_cls_U0_ap_idle;
wire    select_cls_U0_ap_ready;
wire   [12:0] select_cls_U0_cls_sm_din;
wire    select_cls_U0_cls_sm_write;
wire    select_cls_U0_start_out;
wire    select_cls_U0_start_write;
wire    select_cls_U0_i_stream_TREADY;
wire    do_layernorm_U0_ap_start;
wire    do_layernorm_U0_ap_done;
wire    do_layernorm_U0_ap_continue;
wire    do_layernorm_U0_ap_idle;
wire    do_layernorm_U0_ap_ready;
wire    do_layernorm_U0_cls_sm_read;
wire   [7:0] do_layernorm_U0_ln_sm_din;
wire    do_layernorm_U0_ln_sm_write;
wire    do_layernorm_U0_start_out;
wire    do_layernorm_U0_start_write;
wire    do_matmul_U0_ln_sm_read;
wire   [31:0] do_matmul_U0_o_stream_TDATA;
wire    do_matmul_U0_ap_start;
wire    do_matmul_U0_o_stream_TVALID;
wire    do_matmul_U0_ap_done;
wire    do_matmul_U0_ap_ready;
wire    do_matmul_U0_ap_idle;
wire    do_matmul_U0_ap_continue;
wire    cls_sm_full_n;
wire   [12:0] cls_sm_dout;
wire   [2:0] cls_sm_num_data_valid;
wire   [2:0] cls_sm_fifo_cap;
wire    cls_sm_empty_n;
wire    ln_sm_full_n;
wire   [7:0] ln_sm_dout;
wire   [2:0] ln_sm_num_data_valid;
wire   [2:0] ln_sm_fifo_cap;
wire    ln_sm_empty_n;
wire   [0:0] start_for_do_layernorm_U0_din;
wire    start_for_do_layernorm_U0_full_n;
wire   [0:0] start_for_do_layernorm_U0_dout;
wire    start_for_do_layernorm_U0_empty_n;
wire   [0:0] start_for_do_matmul_U0_din;
wire    start_for_do_matmul_U0_full_n;
wire   [0:0] start_for_do_matmul_U0_dout;
wire    start_for_do_matmul_U0_empty_n;

HEAD_select_cls select_cls_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(select_cls_U0_ap_start),
    .start_full_n(start_for_do_layernorm_U0_full_n),
    .ap_done(select_cls_U0_ap_done),
    .ap_continue(select_cls_U0_ap_continue),
    .ap_idle(select_cls_U0_ap_idle),
    .ap_ready(select_cls_U0_ap_ready),
    .i_stream_TVALID(i_stream_TVALID),
    .cls_sm_din(select_cls_U0_cls_sm_din),
    .cls_sm_num_data_valid(cls_sm_num_data_valid),
    .cls_sm_fifo_cap(cls_sm_fifo_cap),
    .cls_sm_full_n(cls_sm_full_n),
    .cls_sm_write(select_cls_U0_cls_sm_write),
    .start_out(select_cls_U0_start_out),
    .start_write(select_cls_U0_start_write),
    .i_stream_TDATA(i_stream_TDATA),
    .i_stream_TREADY(select_cls_U0_i_stream_TREADY)
);

HEAD_do_layernorm do_layernorm_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(do_layernorm_U0_ap_start),
    .start_full_n(start_for_do_matmul_U0_full_n),
    .ap_done(do_layernorm_U0_ap_done),
    .ap_continue(do_layernorm_U0_ap_continue),
    .ap_idle(do_layernorm_U0_ap_idle),
    .ap_ready(do_layernorm_U0_ap_ready),
    .cls_sm_dout(cls_sm_dout),
    .cls_sm_num_data_valid(cls_sm_num_data_valid),
    .cls_sm_fifo_cap(cls_sm_fifo_cap),
    .cls_sm_empty_n(cls_sm_empty_n),
    .cls_sm_read(do_layernorm_U0_cls_sm_read),
    .ln_sm_din(do_layernorm_U0_ln_sm_din),
    .ln_sm_num_data_valid(ln_sm_num_data_valid),
    .ln_sm_fifo_cap(ln_sm_fifo_cap),
    .ln_sm_full_n(ln_sm_full_n),
    .ln_sm_write(do_layernorm_U0_ln_sm_write),
    .start_out(do_layernorm_U0_start_out),
    .start_write(do_layernorm_U0_start_write)
);

HEAD_do_matmul do_matmul_U0(
    .ln_sm_dout(ln_sm_dout),
    .ln_sm_empty_n(ln_sm_empty_n),
    .ln_sm_read(do_matmul_U0_ln_sm_read),
    .o_stream_TDATA(do_matmul_U0_o_stream_TDATA),
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(do_matmul_U0_ap_start),
    .o_stream_TVALID(do_matmul_U0_o_stream_TVALID),
    .o_stream_TREADY(o_stream_TREADY),
    .ap_done(do_matmul_U0_ap_done),
    .ap_ready(do_matmul_U0_ap_ready),
    .ap_idle(do_matmul_U0_ap_idle),
    .ap_continue(do_matmul_U0_ap_continue)
);

HEAD_fifo_w13_d2_S cls_sm_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(select_cls_U0_cls_sm_din),
    .if_full_n(cls_sm_full_n),
    .if_write(select_cls_U0_cls_sm_write),
    .if_dout(cls_sm_dout),
    .if_num_data_valid(cls_sm_num_data_valid),
    .if_fifo_cap(cls_sm_fifo_cap),
    .if_empty_n(cls_sm_empty_n),
    .if_read(do_layernorm_U0_cls_sm_read)
);

HEAD_fifo_w8_d2_S_x ln_sm_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(do_layernorm_U0_ln_sm_din),
    .if_full_n(ln_sm_full_n),
    .if_write(do_layernorm_U0_ln_sm_write),
    .if_dout(ln_sm_dout),
    .if_num_data_valid(ln_sm_num_data_valid),
    .if_fifo_cap(ln_sm_fifo_cap),
    .if_empty_n(ln_sm_empty_n),
    .if_read(do_matmul_U0_ln_sm_read)
);

HEAD_start_for_do_layernorm_U0 start_for_do_layernorm_U0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(start_for_do_layernorm_U0_din),
    .if_full_n(start_for_do_layernorm_U0_full_n),
    .if_write(select_cls_U0_start_write),
    .if_dout(start_for_do_layernorm_U0_dout),
    .if_empty_n(start_for_do_layernorm_U0_empty_n),
    .if_read(do_layernorm_U0_ap_ready)
);

HEAD_start_for_do_matmul_U0 start_for_do_matmul_U0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(start_for_do_matmul_U0_din),
    .if_full_n(start_for_do_matmul_U0_full_n),
    .if_write(do_layernorm_U0_start_write),
    .if_dout(start_for_do_matmul_U0_dout),
    .if_empty_n(start_for_do_matmul_U0_empty_n),
    .if_read(do_matmul_U0_ap_ready)
);

assign ap_done = do_matmul_U0_ap_done;

assign ap_idle = (select_cls_U0_ap_idle & do_matmul_U0_ap_idle & do_layernorm_U0_ap_idle);

assign ap_ready = select_cls_U0_ap_ready;

assign do_layernorm_U0_ap_continue = 1'b1;

assign do_layernorm_U0_ap_start = start_for_do_layernorm_U0_empty_n;

assign do_matmul_U0_ap_continue = ap_continue;

assign do_matmul_U0_ap_start = start_for_do_matmul_U0_empty_n;

assign i_stream_TREADY = select_cls_U0_i_stream_TREADY;

assign o_stream_TDATA = do_matmul_U0_o_stream_TDATA;

assign o_stream_TVALID = do_matmul_U0_o_stream_TVALID;

assign select_cls_U0_ap_continue = 1'b1;

assign select_cls_U0_ap_start = ap_start;

assign start_for_do_layernorm_U0_din = 1'b1;

assign start_for_do_matmul_U0_din = 1'b1;

endmodule //HEAD_do_head
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_do_layernorm (
        ap_clk,
        ap_rst,
        ap_start,
        start_full_n,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        cls_sm_dout,
        cls_sm_num_data_valid,
        cls_sm_fifo_cap,
        cls_sm_empty_n,
        cls_sm_read,
        ln_sm_din,
        ln_sm_num_data_valid,
        ln_sm_fifo_cap,
        ln_sm_full_n,
        ln_sm_write,
        start_out,
        start_write
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
input   start_full_n;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input  [12:0] cls_sm_dout;
input  [2:0] cls_sm_num_data_valid;
input  [2:0] cls_sm_fifo_cap;
input   cls_sm_empty_n;
output   cls_sm_read;
output  [7:0] ln_sm_din;
input  [2:0] ln_sm_num_data_valid;
input  [2:0] ln_sm_fifo_cap;
input   ln_sm_full_n;
output   ln_sm_write;
output   start_out;
output   start_write;

reg ap_idle;
reg cls_sm_read;
reg ln_sm_write;
reg start_write;

reg    real_start;
reg    start_once_reg;
(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_enable_reg_pp0_iter2;
reg    ap_enable_reg_pp0_iter3;
reg    ap_enable_reg_pp0_iter4;
reg    ap_enable_reg_pp0_iter5;
reg    ap_enable_reg_pp0_iter6;
reg    ap_enable_reg_pp0_iter7;
reg    ap_enable_reg_pp0_iter8;
reg    ap_enable_reg_pp0_iter9;
reg    ap_enable_reg_pp0_iter10;
reg    ap_enable_reg_pp0_iter11;
reg    ap_enable_reg_pp0_iter12;
reg    ap_enable_reg_pp0_iter13;
reg    ap_idle_pp0;
wire    internal_ap_ready;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [1:0] select_ln108_1_reg_765;
reg    ap_predicate_op80_read_state2;
reg    ap_block_state2_pp0_stage0_iter1;
reg   [1:0] select_ln108_1_reg_765_pp0_iter12_reg;
reg    ap_block_state14_pp0_stage0_iter13;
reg    ap_block_pp0_stage0_subdone;
wire   [0:0] icmp_ln108_fu_275_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [6:0] HEAD_INST_lnq_rsqrt_table_address0;
reg    HEAD_INST_lnq_rsqrt_table_ce0;
wire   [10:0] HEAD_INST_lnq_rsqrt_table_q0;
wire   [7:0] HEAD_INST_lnq_lnw_address0;
reg    HEAD_INST_lnq_lnw_ce0;
wire   [15:0] HEAD_INST_lnq_lnw_q0;
wire   [7:0] HEAD_INST_lnq_lnb_address0;
reg    HEAD_INST_lnq_lnb_ce0;
wire   [34:0] HEAD_INST_lnq_lnb_q0;
reg    cls_sm_blk_n;
wire    ap_block_pp0_stage0;
reg    ln_sm_blk_n;
reg    ap_block_pp0_stage0_11001;
wire   [7:0] select_ln108_fu_305_p3;
reg   [7:0] select_ln108_reg_758;
wire   [1:0] select_ln108_1_fu_313_p3;
reg   [1:0] select_ln108_1_reg_765_pp0_iter1_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter2_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter3_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter4_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter5_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter6_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter7_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter8_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter9_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter10_reg;
reg   [1:0] select_ln108_1_reg_765_pp0_iter11_reg;
wire   [0:0] grp_fu_211_p2;
reg   [0:0] cmp89_reg_774;
reg   [0:0] cmp89_reg_774_pp0_iter2_reg;
reg   [0:0] cmp89_reg_774_pp0_iter3_reg;
reg   [0:0] cmp89_reg_774_pp0_iter4_reg;
reg   [0:0] cmp89_reg_774_pp0_iter5_reg;
wire   [0:0] grp_fu_216_p2;
reg   [0:0] icmp_ln163_reg_779;
reg   [0:0] icmp_ln163_reg_779_pp0_iter2_reg;
reg   [0:0] icmp_ln163_reg_779_pp0_iter3_reg;
reg   [0:0] icmp_ln163_reg_779_pp0_iter4_reg;
reg   [0:0] icmp_ln163_reg_779_pp0_iter5_reg;
reg   [0:0] icmp_ln163_reg_779_pp0_iter6_reg;
reg   [0:0] icmp_ln163_reg_779_pp0_iter7_reg;
reg  signed [12:0] cls_sm_read_reg_793;
reg   [0:0] icmp_ln119_reg_798;
reg   [0:0] icmp_ln137_reg_803;
reg   [0:0] icmp_ln137_reg_803_pp0_iter2_reg;
reg   [0:0] icmp_ln137_reg_803_pp0_iter3_reg;
reg   [0:0] icmp_ln137_reg_803_pp0_iter4_reg;
wire   [12:0] buffer_q1;
reg   [12:0] buffer_load_reg_807;
reg   [12:0] buffer_load_reg_807_pp0_iter3_reg;
reg   [12:0] buffer_load_reg_807_pp0_iter4_reg;
reg   [12:0] buffer_load_reg_807_pp0_iter5_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter3_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter4_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter5_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter6_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter7_reg;
reg   [15:0] HEAD_INST_lnq_lnw_load_reg_813_pp0_iter8_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter3_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter4_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter5_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter6_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter7_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter8_reg;
reg   [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter9_reg;
reg  signed [34:0] HEAD_INST_lnq_lnb_load_reg_818_pp0_iter10_reg;
wire  signed [23:0] sext_ln156_fu_449_p1;
wire   [22:0] trunc_ln166_fu_516_p1;
reg   [22:0] trunc_ln166_reg_834;
wire   [12:0] diff_1_fu_530_p2;
reg   [12:0] diff_1_reg_839;
reg  signed [12:0] diff_1_reg_839_pp0_iter7_reg;
wire  signed [35:0] grp_fu_682_p3;
reg  signed [35:0] val_reg_874;
wire   [0:0] icmp_ln7_fu_619_p2;
reg   [0:0] icmp_ln7_reg_879;
wire   [0:0] icmp_ln8_fu_634_p2;
reg   [0:0] icmp_ln8_reg_885;
wire   [7:0] buffer_address1;
reg    buffer_ce1;
reg    buffer_we1;
wire   [63:0] zext_ln109_fu_363_p1;
wire   [63:0] zext_ln168_fu_550_p1;
reg   [7:0] ct_fu_110;
wire   [7:0] add_ln109_fu_321_p2;
wire    ap_loop_init;
reg   [7:0] ap_sig_allocacmp_ct_load;
reg   [1:0] state_fu_114;
reg   [1:0] ap_sig_allocacmp_state_load;
reg   [9:0] indvar_flatten_fu_118;
wire   [9:0] add_ln108_fu_269_p2;
reg   [9:0] ap_sig_allocacmp_indvar_flatten_load;
reg   [6:0] empty_fu_122;
reg   [10:0] empty_32_fu_126;
reg   [23:0] empty_33_fu_130;
wire   [23:0] select_ln158_fu_497_p3;
reg   [14:0] empty_34_fu_134;
wire   [14:0] add_ln132_fu_407_p2;
reg    ap_block_pp0_stage0_01001;
wire   [0:0] icmp_ln109_fu_299_p2;
wire   [1:0] state_2_fu_293_p2;
wire   [14:0] select_ln119_fu_397_p3;
wire  signed [14:0] sext_ln132_fu_404_p1;
wire   [12:0] zext_ln155_fu_440_p1;
wire   [12:0] diff_fu_444_p2;
wire  signed [12:0] grp_fu_461_p0;
wire  signed [12:0] grp_fu_461_p1;
wire   [29:0] grp_fu_673_p3;
wire   [23:0] grp_fu_461_p2;
wire   [23:0] add_ln158_fu_491_p2;
wire   [12:0] zext_ln182_fu_526_p1;
wire   [22:0] add_ln166_fu_535_p2;
wire   [5:0] cursor_fu_540_p4;
wire   [10:0] grp_fu_586_p1;
wire  signed [23:0] grp_fu_586_p2;
wire   [8:0] rel_fu_610_p4;
wire   [1:0] tmp_1_fu_625_p4;
wire   [0:0] or_ln187_fu_656_p2;
wire   [7:0] select_ln187_fu_649_p3;
wire   [7:0] trunc_ln_fu_640_p4;
wire   [14:0] grp_fu_673_p0;
wire   [15:0] grp_fu_673_p1;
wire   [22:0] grp_fu_673_p2;
wire   [15:0] grp_fu_682_p1;
reg    grp_fu_461_ce;
reg    grp_fu_586_ce;
reg    grp_fu_673_ce;
reg    grp_fu_682_ce;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg    ap_loop_exit_ready_pp0_iter2_reg;
reg    ap_loop_exit_ready_pp0_iter3_reg;
reg    ap_loop_exit_ready_pp0_iter4_reg;
reg    ap_loop_exit_ready_pp0_iter5_reg;
reg    ap_loop_exit_ready_pp0_iter6_reg;
reg    ap_loop_exit_ready_pp0_iter7_reg;
reg    ap_loop_exit_ready_pp0_iter8_reg;
reg    ap_loop_exit_ready_pp0_iter9_reg;
reg    ap_loop_exit_ready_pp0_iter10_reg;
reg    ap_loop_exit_ready_pp0_iter11_reg;
reg    ap_loop_exit_ready_pp0_iter12_reg;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
wire   [23:0] grp_fu_586_p10;
wire   [29:0] grp_fu_673_p00;
wire   [35:0] grp_fu_682_p10;
reg    ap_condition_348;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 start_once_reg = 1'b0;
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_enable_reg_pp0_iter2 = 1'b0;
//#0 ap_enable_reg_pp0_iter3 = 1'b0;
//#0 ap_enable_reg_pp0_iter4 = 1'b0;
//#0 ap_enable_reg_pp0_iter5 = 1'b0;
//#0 ap_enable_reg_pp0_iter6 = 1'b0;
//#0 ap_enable_reg_pp0_iter7 = 1'b0;
//#0 ap_enable_reg_pp0_iter8 = 1'b0;
//#0 ap_enable_reg_pp0_iter9 = 1'b0;
//#0 ap_enable_reg_pp0_iter10 = 1'b0;
//#0 ap_enable_reg_pp0_iter11 = 1'b0;
//#0 ap_enable_reg_pp0_iter12 = 1'b0;
//#0 ap_enable_reg_pp0_iter13 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 ct_fu_110 = 8'd0;
//#0 state_fu_114 = 2'd0;
//#0 indvar_flatten_fu_118 = 10'd0;
//#0 empty_fu_122 = 7'd0;
//#0 empty_32_fu_126 = 11'd0;
//#0 empty_33_fu_130 = 24'd0;
//#0 empty_34_fu_134 = 15'd0;
end

HEAD_do_layernorm_HEAD_INST_lnq_rsqrt_table_ROM_2P_LUTRAM_1R #(
    .DataWidth( 11 ),
    .AddressRange( 128 ),
    .AddressWidth( 7 ))
HEAD_INST_lnq_rsqrt_table_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(HEAD_INST_lnq_rsqrt_table_address0),
    .ce0(HEAD_INST_lnq_rsqrt_table_ce0),
    .q0(HEAD_INST_lnq_rsqrt_table_q0)
);

HEAD_do_layernorm_HEAD_INST_lnq_lnw_ROM_1P_LUTRAM_1R #(
    .DataWidth( 16 ),
    .AddressRange( 192 ),
    .AddressWidth( 8 ))
HEAD_INST_lnq_lnw_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(HEAD_INST_lnq_lnw_address0),
    .ce0(HEAD_INST_lnq_lnw_ce0),
    .q0(HEAD_INST_lnq_lnw_q0)
);

HEAD_do_layernorm_HEAD_INST_lnq_lnb_ROM_1P_LUTRAM_1R #(
    .DataWidth( 35 ),
    .AddressRange( 192 ),
    .AddressWidth( 8 ))
HEAD_INST_lnq_lnb_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(HEAD_INST_lnq_lnb_address0),
    .ce0(HEAD_INST_lnq_lnb_ce0),
    .q0(HEAD_INST_lnq_lnb_q0)
);

HEAD_do_layernorm_buffer_RAM_2P_LUTRAM_1R1W #(
    .DataWidth( 13 ),
    .AddressRange( 192 ),
    .AddressWidth( 8 ))
buffer_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address1(buffer_address1),
    .ce1(buffer_ce1),
    .we1(buffer_we1),
    .d1(cls_sm_dout),
    .q1(buffer_q1)
);

HEAD_mul_13s_13s_24_2_1 #(
    .ID( 1 ),
    .NUM_STAGE( 2 ),
    .din0_WIDTH( 13 ),
    .din1_WIDTH( 13 ),
    .dout_WIDTH( 24 ))
mul_13s_13s_24_2_1_U4(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(grp_fu_461_p0),
    .din1(grp_fu_461_p1),
    .ce(grp_fu_461_ce),
    .dout(grp_fu_461_p2)
);

HEAD_mul_13s_11ns_24_2_1 #(
    .ID( 1 ),
    .NUM_STAGE( 2 ),
    .din0_WIDTH( 13 ),
    .din1_WIDTH( 11 ),
    .dout_WIDTH( 24 ))
mul_13s_11ns_24_2_1_U5(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(diff_1_reg_839_pp0_iter7_reg),
    .din1(grp_fu_586_p1),
    .ce(grp_fu_586_ce),
    .dout(grp_fu_586_p2)
);

HEAD_mac_muladd_15ns_16ns_23ns_30_4_1 #(
    .ID( 1 ),
    .NUM_STAGE( 4 ),
    .din0_WIDTH( 15 ),
    .din1_WIDTH( 16 ),
    .din2_WIDTH( 23 ),
    .dout_WIDTH( 30 ))
mac_muladd_15ns_16ns_23ns_30_4_1_U6(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(grp_fu_673_p0),
    .din1(grp_fu_673_p1),
    .din2(grp_fu_673_p2),
    .ce(grp_fu_673_ce),
    .dout(grp_fu_673_p3)
);

HEAD_mac_muladd_24s_16ns_35s_36_4_1 #(
    .ID( 1 ),
    .NUM_STAGE( 4 ),
    .din0_WIDTH( 24 ),
    .din1_WIDTH( 16 ),
    .din2_WIDTH( 35 ),
    .dout_WIDTH( 36 ))
mac_muladd_24s_16ns_35s_36_4_1_U7(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(grp_fu_586_p2),
    .din1(grp_fu_682_p1),
    .din2(HEAD_INST_lnq_lnb_load_reg_818_pp0_iter10_reg),
    .ce(grp_fu_682_ce),
    .dout(grp_fu_682_p3)
);

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(real_start),
    .ap_ready(internal_ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter12_reg == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin
            ap_enable_reg_pp0_iter1 <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter10 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter10 <= ap_enable_reg_pp0_iter9;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter11 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter11 <= ap_enable_reg_pp0_iter10;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter12 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter12 <= ap_enable_reg_pp0_iter11;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter13 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter13 <= ap_enable_reg_pp0_iter12;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter2 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter2 <= ap_enable_reg_pp0_iter1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter3 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter3 <= ap_enable_reg_pp0_iter2;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter4 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter4 <= ap_enable_reg_pp0_iter3;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter5 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter5 <= ap_enable_reg_pp0_iter4;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter6 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter6 <= ap_enable_reg_pp0_iter5;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter7 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter7 <= ap_enable_reg_pp0_iter6;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter8 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter8 <= ap_enable_reg_pp0_iter7;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter9 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter9 <= ap_enable_reg_pp0_iter8;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        start_once_reg <= 1'b0;
    end else begin
        if (((real_start == 1'b1) & (internal_ap_ready == 1'b0))) begin
            start_once_reg <= 1'b1;
        end else if ((internal_ap_ready == 1'b1)) begin
            start_once_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_348)) begin
        if ((icmp_ln108_fu_275_p2 == 1'd0)) begin
            ct_fu_110 <= add_ln109_fu_321_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            ct_fu_110 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_348)) begin
        if ((icmp_ln108_fu_275_p2 == 1'd0)) begin
            indvar_flatten_fu_118 <= add_ln108_fu_269_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            indvar_flatten_fu_118 <= 10'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_348)) begin
        if ((icmp_ln108_fu_275_p2 == 1'd0)) begin
            state_fu_114 <= select_ln108_1_fu_313_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            state_fu_114 <= 2'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b0 == ap_block_pp0_stage0_11001)) begin
        HEAD_INST_lnq_lnb_load_reg_818 <= HEAD_INST_lnq_lnb_q0;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter10_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter9_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter3_reg <= HEAD_INST_lnq_lnb_load_reg_818;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter4_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter3_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter5_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter4_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter6_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter5_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter7_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter6_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter8_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter7_reg;
        HEAD_INST_lnq_lnb_load_reg_818_pp0_iter9_reg <= HEAD_INST_lnq_lnb_load_reg_818_pp0_iter8_reg;
        HEAD_INST_lnq_lnw_load_reg_813 <= HEAD_INST_lnq_lnw_q0;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter3_reg <= HEAD_INST_lnq_lnw_load_reg_813;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter4_reg <= HEAD_INST_lnq_lnw_load_reg_813_pp0_iter3_reg;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter5_reg <= HEAD_INST_lnq_lnw_load_reg_813_pp0_iter4_reg;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter6_reg <= HEAD_INST_lnq_lnw_load_reg_813_pp0_iter5_reg;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter7_reg <= HEAD_INST_lnq_lnw_load_reg_813_pp0_iter6_reg;
        HEAD_INST_lnq_lnw_load_reg_813_pp0_iter8_reg <= HEAD_INST_lnq_lnw_load_reg_813_pp0_iter7_reg;
        ap_loop_exit_ready_pp0_iter10_reg <= ap_loop_exit_ready_pp0_iter9_reg;
        ap_loop_exit_ready_pp0_iter11_reg <= ap_loop_exit_ready_pp0_iter10_reg;
        ap_loop_exit_ready_pp0_iter12_reg <= ap_loop_exit_ready_pp0_iter11_reg;
        ap_loop_exit_ready_pp0_iter3_reg <= ap_loop_exit_ready_pp0_iter2_reg;
        ap_loop_exit_ready_pp0_iter4_reg <= ap_loop_exit_ready_pp0_iter3_reg;
        ap_loop_exit_ready_pp0_iter5_reg <= ap_loop_exit_ready_pp0_iter4_reg;
        ap_loop_exit_ready_pp0_iter6_reg <= ap_loop_exit_ready_pp0_iter5_reg;
        ap_loop_exit_ready_pp0_iter7_reg <= ap_loop_exit_ready_pp0_iter6_reg;
        ap_loop_exit_ready_pp0_iter8_reg <= ap_loop_exit_ready_pp0_iter7_reg;
        ap_loop_exit_ready_pp0_iter9_reg <= ap_loop_exit_ready_pp0_iter8_reg;
        buffer_load_reg_807_pp0_iter3_reg <= buffer_load_reg_807;
        buffer_load_reg_807_pp0_iter4_reg <= buffer_load_reg_807_pp0_iter3_reg;
        buffer_load_reg_807_pp0_iter5_reg <= buffer_load_reg_807_pp0_iter4_reg;
        cmp89_reg_774_pp0_iter2_reg <= cmp89_reg_774;
        cmp89_reg_774_pp0_iter3_reg <= cmp89_reg_774_pp0_iter2_reg;
        cmp89_reg_774_pp0_iter4_reg <= cmp89_reg_774_pp0_iter3_reg;
        cmp89_reg_774_pp0_iter5_reg <= cmp89_reg_774_pp0_iter4_reg;
        diff_1_reg_839 <= diff_1_fu_530_p2;
        diff_1_reg_839_pp0_iter7_reg <= diff_1_reg_839;
        icmp_ln137_reg_803_pp0_iter2_reg <= icmp_ln137_reg_803;
        icmp_ln137_reg_803_pp0_iter3_reg <= icmp_ln137_reg_803_pp0_iter2_reg;
        icmp_ln137_reg_803_pp0_iter4_reg <= icmp_ln137_reg_803_pp0_iter3_reg;
        icmp_ln163_reg_779_pp0_iter2_reg <= icmp_ln163_reg_779;
        icmp_ln163_reg_779_pp0_iter3_reg <= icmp_ln163_reg_779_pp0_iter2_reg;
        icmp_ln163_reg_779_pp0_iter4_reg <= icmp_ln163_reg_779_pp0_iter3_reg;
        icmp_ln163_reg_779_pp0_iter5_reg <= icmp_ln163_reg_779_pp0_iter4_reg;
        icmp_ln163_reg_779_pp0_iter6_reg <= icmp_ln163_reg_779_pp0_iter5_reg;
        icmp_ln163_reg_779_pp0_iter7_reg <= icmp_ln163_reg_779_pp0_iter6_reg;
        icmp_ln7_reg_879 <= icmp_ln7_fu_619_p2;
        icmp_ln8_reg_885 <= icmp_ln8_fu_634_p2;
        select_ln108_1_reg_765_pp0_iter10_reg <= select_ln108_1_reg_765_pp0_iter9_reg;
        select_ln108_1_reg_765_pp0_iter11_reg <= select_ln108_1_reg_765_pp0_iter10_reg;
        select_ln108_1_reg_765_pp0_iter12_reg <= select_ln108_1_reg_765_pp0_iter11_reg;
        select_ln108_1_reg_765_pp0_iter2_reg <= select_ln108_1_reg_765_pp0_iter1_reg;
        select_ln108_1_reg_765_pp0_iter3_reg <= select_ln108_1_reg_765_pp0_iter2_reg;
        select_ln108_1_reg_765_pp0_iter4_reg <= select_ln108_1_reg_765_pp0_iter3_reg;
        select_ln108_1_reg_765_pp0_iter5_reg <= select_ln108_1_reg_765_pp0_iter4_reg;
        select_ln108_1_reg_765_pp0_iter6_reg <= select_ln108_1_reg_765_pp0_iter5_reg;
        select_ln108_1_reg_765_pp0_iter7_reg <= select_ln108_1_reg_765_pp0_iter6_reg;
        select_ln108_1_reg_765_pp0_iter8_reg <= select_ln108_1_reg_765_pp0_iter7_reg;
        select_ln108_1_reg_765_pp0_iter9_reg <= select_ln108_1_reg_765_pp0_iter8_reg;
        trunc_ln166_reg_834 <= trunc_ln166_fu_516_p1;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        ap_loop_exit_ready_pp0_iter2_reg <= ap_loop_exit_ready_pp0_iter1_reg;
        cls_sm_read_reg_793 <= cls_sm_dout;
        select_ln108_1_reg_765 <= select_ln108_1_fu_313_p3;
        select_ln108_1_reg_765_pp0_iter1_reg <= select_ln108_1_reg_765;
        select_ln108_reg_758 <= select_ln108_fu_305_p3;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        buffer_load_reg_807 <= buffer_q1;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        cmp89_reg_774 <= grp_fu_211_p2;
        icmp_ln119_reg_798 <= grp_fu_211_p2;
        icmp_ln137_reg_803 <= grp_fu_216_p2;
        icmp_ln163_reg_779 <= grp_fu_216_p2;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter8 == 1'b1) & (icmp_ln163_reg_779_pp0_iter7_reg == 1'd1) & (select_ln108_1_reg_765_pp0_iter7_reg == 2'd1))) begin
        empty_32_fu_126 <= HEAD_INST_lnq_rsqrt_table_q0;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter6 == 1'b1) & (select_ln108_1_reg_765_pp0_iter5_reg == 2'd1))) begin
        empty_33_fu_130 <= select_ln158_fu_497_p3;
    end
end

always @ (posedge ap_clk) begin
    if ((~(select_ln108_1_reg_765_pp0_iter1_reg == 2'd1) & ~(select_ln108_1_reg_765_pp0_iter1_reg == 2'd2) & (1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        empty_34_fu_134 <= add_ln132_fu_407_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~(select_ln108_1_reg_765_pp0_iter4_reg == 2'd1) & ~(select_ln108_1_reg_765_pp0_iter4_reg == 2'd2) & (1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter5 == 1'b1) & (icmp_ln137_reg_803_pp0_iter4_reg == 1'd1))) begin
        empty_fu_122 <= {{grp_fu_673_p3[29:23]}};
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter12 == 1'b1))) begin
        val_reg_874 <= grp_fu_682_p3;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        HEAD_INST_lnq_lnb_ce0 = 1'b1;
    end else begin
        HEAD_INST_lnq_lnb_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        HEAD_INST_lnq_lnw_ce0 = 1'b1;
    end else begin
        HEAD_INST_lnq_lnw_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter7 == 1'b1))) begin
        HEAD_INST_lnq_rsqrt_table_ce0 = 1'b1;
    end else begin
        HEAD_INST_lnq_rsqrt_table_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (icmp_ln108_fu_275_p2 == 1'd1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter12_reg == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (ap_idle_pp0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter13 == 1'b0) & (ap_enable_reg_pp0_iter12 == 1'b0) & (ap_enable_reg_pp0_iter11 == 1'b0) & (ap_enable_reg_pp0_iter10 == 1'b0) & (ap_enable_reg_pp0_iter9 == 1'b0) & (ap_enable_reg_pp0_iter8 == 1'b0) & (ap_enable_reg_pp0_iter7 == 1'b0) & (ap_enable_reg_pp0_iter6 == 1'b0) & (ap_enable_reg_pp0_iter5 == 1'b0) & (ap_enable_reg_pp0_iter4 == 1'b0) & (ap_enable_reg_pp0_iter3 == 1'b0) & (ap_enable_reg_pp0_iter2 == 1'b0) & (ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_loop_init == 1'b1) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_ct_load = 8'd0;
    end else begin
        ap_sig_allocacmp_ct_load = ct_fu_110;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_loop_init == 1'b1) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_indvar_flatten_load = 10'd0;
    end else begin
        ap_sig_allocacmp_indvar_flatten_load = indvar_flatten_fu_118;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_loop_init == 1'b1) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_state_load = 2'd0;
    end else begin
        ap_sig_allocacmp_state_load = state_fu_114;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        buffer_ce1 = 1'b1;
    end else begin
        buffer_ce1 = 1'b0;
    end
end

always @ (*) begin
    if ((~(select_ln108_1_reg_765 == 2'd1) & ~(select_ln108_1_reg_765 == 2'd2) & (1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        buffer_we1 = 1'b1;
    end else begin
        buffer_we1 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_predicate_op80_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        cls_sm_blk_n = cls_sm_empty_n;
    end else begin
        cls_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_predicate_op80_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        cls_sm_read = 1'b1;
    end else begin
        cls_sm_read = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        grp_fu_461_ce = 1'b1;
    end else begin
        grp_fu_461_ce = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        grp_fu_586_ce = 1'b1;
    end else begin
        grp_fu_586_ce = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        grp_fu_673_ce = 1'b1;
    end else begin
        grp_fu_673_ce = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        grp_fu_682_ce = 1'b1;
    end else begin
        grp_fu_682_ce = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter13 == 1'b1) & (select_ln108_1_reg_765_pp0_iter12_reg == 2'd2))) begin
        ln_sm_blk_n = ln_sm_full_n;
    end else begin
        ln_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter13 == 1'b1) & (select_ln108_1_reg_765_pp0_iter12_reg == 2'd2))) begin
        ln_sm_write = 1'b1;
    end else begin
        ln_sm_write = 1'b0;
    end
end

always @ (*) begin
    if (((start_full_n == 1'b0) & (start_once_reg == 1'b0))) begin
        real_start = 1'b0;
    end else begin
        real_start = ap_start;
    end
end

always @ (*) begin
    if (((real_start == 1'b1) & (start_once_reg == 1'b0))) begin
        start_write = 1'b1;
    end else begin
        start_write = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign HEAD_INST_lnq_lnb_address0 = zext_ln109_fu_363_p1;

assign HEAD_INST_lnq_lnw_address0 = zext_ln109_fu_363_p1;

assign HEAD_INST_lnq_rsqrt_table_address0 = zext_ln168_fu_550_p1;

assign add_ln108_fu_269_p2 = (ap_sig_allocacmp_indvar_flatten_load + 10'd1);

assign add_ln109_fu_321_p2 = (select_ln108_fu_305_p3 + 8'd1);

assign add_ln132_fu_407_p2 = ($signed(select_ln119_fu_397_p3) + $signed(sext_ln132_fu_404_p1));

assign add_ln158_fu_491_p2 = (grp_fu_461_p2 + empty_33_fu_130);

assign add_ln166_fu_535_p2 = ($signed(trunc_ln166_reg_834) + $signed(23'd7727614));

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)) | ((ap_enable_reg_pp0_iter13 == 1'b1) & (1'b1 == ap_block_state14_pp0_stage0_iter13)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)) | ((ap_enable_reg_pp0_iter13 == 1'b1) & (1'b1 == ap_block_state14_pp0_stage0_iter13)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)) | ((ap_enable_reg_pp0_iter13 == 1'b1) & (1'b1 == ap_block_state14_pp0_stage0_iter13)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)));
end

always @ (*) begin
    ap_block_state14_pp0_stage0_iter13 = ((select_ln108_1_reg_765_pp0_iter12_reg == 2'd2) & (ln_sm_full_n == 1'b0));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_done_reg == 1'b1);
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = ((ap_predicate_op80_read_state2 == 1'b1) & (cls_sm_empty_n == 1'b0));
end

always @ (*) begin
    ap_condition_348 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

always @ (*) begin
    ap_predicate_op80_read_state2 = (~(select_ln108_1_reg_765 == 2'd1) & ~(select_ln108_1_reg_765 == 2'd2));
end

assign ap_ready = internal_ap_ready;

assign buffer_address1 = zext_ln109_fu_363_p1;

assign cursor_fu_540_p4 = {{add_ln166_fu_535_p2[22:17]}};

assign diff_1_fu_530_p2 = (buffer_load_reg_807_pp0_iter5_reg - zext_ln182_fu_526_p1);

assign diff_fu_444_p2 = (buffer_load_reg_807_pp0_iter4_reg - zext_ln155_fu_440_p1);

assign grp_fu_211_p2 = ((select_ln108_reg_758 == 8'd0) ? 1'b1 : 1'b0);

assign grp_fu_216_p2 = ((select_ln108_reg_758 == 8'd191) ? 1'b1 : 1'b0);

assign grp_fu_461_p0 = sext_ln156_fu_449_p1;

assign grp_fu_461_p1 = sext_ln156_fu_449_p1;

assign grp_fu_586_p1 = grp_fu_586_p10;

assign grp_fu_586_p10 = empty_32_fu_126;

assign grp_fu_673_p0 = grp_fu_673_p00;

assign grp_fu_673_p00 = add_ln132_fu_407_p2;

assign grp_fu_673_p1 = 30'd43691;

assign grp_fu_673_p2 = 30'd4194304;

assign grp_fu_682_p1 = grp_fu_682_p10;

assign grp_fu_682_p10 = HEAD_INST_lnq_lnw_load_reg_813_pp0_iter8_reg;

assign icmp_ln108_fu_275_p2 = ((ap_sig_allocacmp_indvar_flatten_load == 10'd576) ? 1'b1 : 1'b0);

assign icmp_ln109_fu_299_p2 = ((ap_sig_allocacmp_ct_load == 8'd192) ? 1'b1 : 1'b0);

assign icmp_ln7_fu_619_p2 = (($signed(rel_fu_610_p4) < $signed(9'd384)) ? 1'b1 : 1'b0);

assign icmp_ln8_fu_634_p2 = ((tmp_1_fu_625_p4 == 2'd1) ? 1'b1 : 1'b0);

assign ln_sm_din = ((or_ln187_fu_656_p2[0:0] == 1'b1) ? select_ln187_fu_649_p3 : trunc_ln_fu_640_p4);

assign or_ln187_fu_656_p2 = (icmp_ln8_reg_885 | icmp_ln7_reg_879);

assign rel_fu_610_p4 = {{grp_fu_682_p3[35:27]}};

assign select_ln108_1_fu_313_p3 = ((icmp_ln109_fu_299_p2[0:0] == 1'b1) ? state_2_fu_293_p2 : ap_sig_allocacmp_state_load);

assign select_ln108_fu_305_p3 = ((icmp_ln109_fu_299_p2[0:0] == 1'b1) ? 8'd0 : ap_sig_allocacmp_ct_load);

assign select_ln119_fu_397_p3 = ((icmp_ln119_reg_798[0:0] == 1'b1) ? 15'd0 : empty_34_fu_134);

assign select_ln158_fu_497_p3 = ((cmp89_reg_774_pp0_iter5_reg[0:0] == 1'b1) ? grp_fu_461_p2 : add_ln158_fu_491_p2);

assign select_ln187_fu_649_p3 = ((icmp_ln7_reg_879[0:0] == 1'b1) ? 8'd128 : 8'd127);

assign sext_ln132_fu_404_p1 = cls_sm_read_reg_793;

assign sext_ln156_fu_449_p1 = $signed(diff_fu_444_p2);

assign start_out = real_start;

assign state_2_fu_293_p2 = (ap_sig_allocacmp_state_load + 2'd1);

assign tmp_1_fu_625_p4 = {{grp_fu_682_p3[35:34]}};

assign trunc_ln166_fu_516_p1 = select_ln158_fu_497_p3[22:0];

assign trunc_ln_fu_640_p4 = {{val_reg_874[34:27]}};

assign zext_ln109_fu_363_p1 = select_ln108_reg_758;

assign zext_ln155_fu_440_p1 = empty_fu_122;

assign zext_ln168_fu_550_p1 = cursor_fu_540_p4;

assign zext_ln182_fu_526_p1 = empty_fu_122;

endmodule //HEAD_do_layernorm
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_do_layernorm_buffer_RAM_2P_LUTRAM_1R1W (
       
    address1, ce1,
    d1, we1, 
    q1, 
     
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 8;
parameter AddressRange = 192;
  
input[AddressWidth-1:0] address1;
input ce1;
input[DataWidth-1:0] d1;
input we1; 
output reg[DataWidth-1:0] q1; 

input reset;
input clk;

(* ram_style = "distributed"  *)reg [DataWidth-1:0] ram[0:AddressRange-1];


   





//read first
always @(posedge clk)  
begin 
    if (ce1) begin
        if (we1) 
            ram[address1] <= d1; 
        q1 <= ram[address1];

    end
end 
 
 

endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_do_layernorm_HEAD_INST_lnq_lnb_ROM_1P_LUTRAM_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 35;
parameter AddressWidth = 8;
parameter AddressRange = 192;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
(* rom_style = "distributed" *)reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("C:/projects/AAAProjects/PROJ06_PyHLS_ViT/SPINAL/src/main/verilog/HEAD/HEAD_do_layernorm_HEAD_INST_lnq_lnb_ROM_1P_LUTRAM_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_do_layernorm_HEAD_INST_lnq_lnw_ROM_1P_LUTRAM_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 16;
parameter AddressWidth = 8;
parameter AddressRange = 192;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
(* rom_style = "distributed" *)reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("C:/projects/AAAProjects/PROJ06_PyHLS_ViT/SPINAL/src/main/verilog/HEAD/HEAD_do_layernorm_HEAD_INST_lnq_lnw_ROM_1P_LUTRAM_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_do_layernorm_HEAD_INST_lnq_rsqrt_table_ROM_2P_LUTRAM_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 11;
parameter AddressWidth = 7;
parameter AddressRange = 128;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
(* rom_style = "distributed" *)reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("C:/projects/AAAProjects/PROJ06_PyHLS_ViT/SPINAL/src/main/verilog/HEAD/HEAD_do_layernorm_HEAD_INST_lnq_rsqrt_table_ROM_2P_LUTRAM_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_do_matmul (
        ln_sm_dout,
        ln_sm_empty_n,
        ln_sm_read,
        o_stream_TDATA,
        ap_clk,
        ap_rst,
        ap_start,
        o_stream_TVALID,
        o_stream_TREADY,
        ap_done,
        ap_ready,
        ap_idle,
        ap_continue
);


input  [7:0] ln_sm_dout;
input   ln_sm_empty_n;
output   ln_sm_read;
output  [31:0] o_stream_TDATA;
input   ap_clk;
input   ap_rst;
input   ap_start;
output   o_stream_TVALID;
input   o_stream_TREADY;
output   ap_done;
output   ap_ready;
output   ap_idle;
input   ap_continue;

wire    do_adapt_U0_ap_start;
wire    do_adapt_U0_ap_done;
wire    do_adapt_U0_ap_continue;
wire    do_adapt_U0_ap_idle;
wire    do_adapt_U0_ap_ready;
wire    do_adapt_U0_ln_sm_read;
wire   [7:0] do_adapt_U0_adpt_sm_din;
wire    do_adapt_U0_adpt_sm_write;
wire    do_adapt_U0_start_out;
wire    do_adapt_U0_start_write;
wire    matmul_step1_cache_window_U0_ap_start;
wire    matmul_step1_cache_window_U0_ap_done;
wire    matmul_step1_cache_window_U0_ap_continue;
wire    matmul_step1_cache_window_U0_ap_idle;
wire    matmul_step1_cache_window_U0_ap_ready;
wire    matmul_step1_cache_window_U0_adpt_sm_read;
wire   [7:0] matmul_step1_cache_window_U0_cache_window_sm_din;
wire    matmul_step1_cache_window_U0_cache_window_sm_write;
wire    matmul_step1_cache_window_U0_start_out;
wire    matmul_step1_cache_window_U0_start_write;
wire    matmul_step2_mac_U0_ap_start;
wire    matmul_step2_mac_U0_ap_done;
wire    matmul_step2_mac_U0_ap_continue;
wire    matmul_step2_mac_U0_ap_idle;
wire    matmul_step2_mac_U0_ap_ready;
wire    matmul_step2_mac_U0_cache_window_sm_read;
wire   [75:0] matmul_step2_mac_U0_mac_sm_din;
wire    matmul_step2_mac_U0_mac_sm_write;
wire    matmul_step2_mac_U0_start_out;
wire    matmul_step2_mac_U0_start_write;
wire    do_adapt_1_U0_ap_start;
wire    do_adapt_1_U0_ap_done;
wire    do_adapt_1_U0_ap_continue;
wire    do_adapt_1_U0_ap_idle;
wire    do_adapt_1_U0_ap_ready;
wire    do_adapt_1_U0_mac_sm_read;
wire   [31:0] do_adapt_1_U0_o_stream_TDATA;
wire    do_adapt_1_U0_o_stream_TVALID;
wire    adpt_sm_full_n;
wire   [7:0] adpt_sm_dout;
wire   [2:0] adpt_sm_num_data_valid;
wire   [2:0] adpt_sm_fifo_cap;
wire    adpt_sm_empty_n;
wire    cache_window_sm_full_n;
wire   [7:0] cache_window_sm_dout;
wire   [2:0] cache_window_sm_num_data_valid;
wire   [2:0] cache_window_sm_fifo_cap;
wire    cache_window_sm_empty_n;
wire    mac_sm_full_n;
wire   [75:0] mac_sm_dout;
wire   [2:0] mac_sm_num_data_valid;
wire   [2:0] mac_sm_fifo_cap;
wire    mac_sm_empty_n;
wire   [0:0] start_for_matmul_step1_cache_window_U0_din;
wire    start_for_matmul_step1_cache_window_U0_full_n;
wire   [0:0] start_for_matmul_step1_cache_window_U0_dout;
wire    start_for_matmul_step1_cache_window_U0_empty_n;
wire   [0:0] start_for_matmul_step2_mac_U0_din;
wire    start_for_matmul_step2_mac_U0_full_n;
wire   [0:0] start_for_matmul_step2_mac_U0_dout;
wire    start_for_matmul_step2_mac_U0_empty_n;
wire   [0:0] start_for_do_adapt_1_U0_din;
wire    start_for_do_adapt_1_U0_full_n;
wire   [0:0] start_for_do_adapt_1_U0_dout;
wire    start_for_do_adapt_1_U0_empty_n;

HEAD_do_adapt do_adapt_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(do_adapt_U0_ap_start),
    .start_full_n(start_for_matmul_step1_cache_window_U0_full_n),
    .ap_done(do_adapt_U0_ap_done),
    .ap_continue(do_adapt_U0_ap_continue),
    .ap_idle(do_adapt_U0_ap_idle),
    .ap_ready(do_adapt_U0_ap_ready),
    .ln_sm_dout(ln_sm_dout),
    .ln_sm_num_data_valid(3'd0),
    .ln_sm_fifo_cap(3'd0),
    .ln_sm_empty_n(ln_sm_empty_n),
    .ln_sm_read(do_adapt_U0_ln_sm_read),
    .adpt_sm_din(do_adapt_U0_adpt_sm_din),
    .adpt_sm_num_data_valid(adpt_sm_num_data_valid),
    .adpt_sm_fifo_cap(adpt_sm_fifo_cap),
    .adpt_sm_full_n(adpt_sm_full_n),
    .adpt_sm_write(do_adapt_U0_adpt_sm_write),
    .start_out(do_adapt_U0_start_out),
    .start_write(do_adapt_U0_start_write)
);

HEAD_matmul_step1_cache_window matmul_step1_cache_window_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(matmul_step1_cache_window_U0_ap_start),
    .start_full_n(start_for_matmul_step2_mac_U0_full_n),
    .ap_done(matmul_step1_cache_window_U0_ap_done),
    .ap_continue(matmul_step1_cache_window_U0_ap_continue),
    .ap_idle(matmul_step1_cache_window_U0_ap_idle),
    .ap_ready(matmul_step1_cache_window_U0_ap_ready),
    .adpt_sm_dout(adpt_sm_dout),
    .adpt_sm_num_data_valid(adpt_sm_num_data_valid),
    .adpt_sm_fifo_cap(adpt_sm_fifo_cap),
    .adpt_sm_empty_n(adpt_sm_empty_n),
    .adpt_sm_read(matmul_step1_cache_window_U0_adpt_sm_read),
    .cache_window_sm_din(matmul_step1_cache_window_U0_cache_window_sm_din),
    .cache_window_sm_num_data_valid(cache_window_sm_num_data_valid),
    .cache_window_sm_fifo_cap(cache_window_sm_fifo_cap),
    .cache_window_sm_full_n(cache_window_sm_full_n),
    .cache_window_sm_write(matmul_step1_cache_window_U0_cache_window_sm_write),
    .start_out(matmul_step1_cache_window_U0_start_out),
    .start_write(matmul_step1_cache_window_U0_start_write)
);

HEAD_matmul_step2_mac matmul_step2_mac_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(matmul_step2_mac_U0_ap_start),
    .start_full_n(start_for_do_adapt_1_U0_full_n),
    .ap_done(matmul_step2_mac_U0_ap_done),
    .ap_continue(matmul_step2_mac_U0_ap_continue),
    .ap_idle(matmul_step2_mac_U0_ap_idle),
    .ap_ready(matmul_step2_mac_U0_ap_ready),
    .cache_window_sm_dout(cache_window_sm_dout),
    .cache_window_sm_num_data_valid(cache_window_sm_num_data_valid),
    .cache_window_sm_fifo_cap(cache_window_sm_fifo_cap),
    .cache_window_sm_empty_n(cache_window_sm_empty_n),
    .cache_window_sm_read(matmul_step2_mac_U0_cache_window_sm_read),
    .mac_sm_din(matmul_step2_mac_U0_mac_sm_din),
    .mac_sm_num_data_valid(mac_sm_num_data_valid),
    .mac_sm_fifo_cap(mac_sm_fifo_cap),
    .mac_sm_full_n(mac_sm_full_n),
    .mac_sm_write(matmul_step2_mac_U0_mac_sm_write),
    .start_out(matmul_step2_mac_U0_start_out),
    .start_write(matmul_step2_mac_U0_start_write)
);

HEAD_do_adapt_1 do_adapt_1_U0(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(do_adapt_1_U0_ap_start),
    .ap_done(do_adapt_1_U0_ap_done),
    .ap_continue(do_adapt_1_U0_ap_continue),
    .ap_idle(do_adapt_1_U0_ap_idle),
    .ap_ready(do_adapt_1_U0_ap_ready),
    .mac_sm_dout(mac_sm_dout),
    .mac_sm_num_data_valid(mac_sm_num_data_valid),
    .mac_sm_fifo_cap(mac_sm_fifo_cap),
    .mac_sm_empty_n(mac_sm_empty_n),
    .mac_sm_read(do_adapt_1_U0_mac_sm_read),
    .o_stream_TREADY(o_stream_TREADY),
    .o_stream_TDATA(do_adapt_1_U0_o_stream_TDATA),
    .o_stream_TVALID(do_adapt_1_U0_o_stream_TVALID)
);

HEAD_fifo_w8_d2_S adpt_sm_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(do_adapt_U0_adpt_sm_din),
    .if_full_n(adpt_sm_full_n),
    .if_write(do_adapt_U0_adpt_sm_write),
    .if_dout(adpt_sm_dout),
    .if_num_data_valid(adpt_sm_num_data_valid),
    .if_fifo_cap(adpt_sm_fifo_cap),
    .if_empty_n(adpt_sm_empty_n),
    .if_read(matmul_step1_cache_window_U0_adpt_sm_read)
);

HEAD_fifo_w8_d2_S cache_window_sm_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(matmul_step1_cache_window_U0_cache_window_sm_din),
    .if_full_n(cache_window_sm_full_n),
    .if_write(matmul_step1_cache_window_U0_cache_window_sm_write),
    .if_dout(cache_window_sm_dout),
    .if_num_data_valid(cache_window_sm_num_data_valid),
    .if_fifo_cap(cache_window_sm_fifo_cap),
    .if_empty_n(cache_window_sm_empty_n),
    .if_read(matmul_step2_mac_U0_cache_window_sm_read)
);

HEAD_fifo_w76_d2_S mac_sm_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(matmul_step2_mac_U0_mac_sm_din),
    .if_full_n(mac_sm_full_n),
    .if_write(matmul_step2_mac_U0_mac_sm_write),
    .if_dout(mac_sm_dout),
    .if_num_data_valid(mac_sm_num_data_valid),
    .if_fifo_cap(mac_sm_fifo_cap),
    .if_empty_n(mac_sm_empty_n),
    .if_read(do_adapt_1_U0_mac_sm_read)
);

HEAD_start_for_matmul_step1_cache_window_U0 start_for_matmul_step1_cache_window_U0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(start_for_matmul_step1_cache_window_U0_din),
    .if_full_n(start_for_matmul_step1_cache_window_U0_full_n),
    .if_write(do_adapt_U0_start_write),
    .if_dout(start_for_matmul_step1_cache_window_U0_dout),
    .if_empty_n(start_for_matmul_step1_cache_window_U0_empty_n),
    .if_read(matmul_step1_cache_window_U0_ap_ready)
);

HEAD_start_for_matmul_step2_mac_U0 start_for_matmul_step2_mac_U0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(start_for_matmul_step2_mac_U0_din),
    .if_full_n(start_for_matmul_step2_mac_U0_full_n),
    .if_write(matmul_step1_cache_window_U0_start_write),
    .if_dout(start_for_matmul_step2_mac_U0_dout),
    .if_empty_n(start_for_matmul_step2_mac_U0_empty_n),
    .if_read(matmul_step2_mac_U0_ap_ready)
);

HEAD_start_for_do_adapt_1_U0 start_for_do_adapt_1_U0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .if_read_ce(1'b1),
    .if_write_ce(1'b1),
    .if_din(start_for_do_adapt_1_U0_din),
    .if_full_n(start_for_do_adapt_1_U0_full_n),
    .if_write(matmul_step2_mac_U0_start_write),
    .if_dout(start_for_do_adapt_1_U0_dout),
    .if_empty_n(start_for_do_adapt_1_U0_empty_n),
    .if_read(do_adapt_1_U0_ap_ready)
);

assign ap_done = do_adapt_1_U0_ap_done;

assign ap_idle = (matmul_step2_mac_U0_ap_idle & matmul_step1_cache_window_U0_ap_idle & do_adapt_U0_ap_idle & do_adapt_1_U0_ap_idle);

assign ap_ready = do_adapt_U0_ap_ready;

assign do_adapt_1_U0_ap_continue = ap_continue;

assign do_adapt_1_U0_ap_start = start_for_do_adapt_1_U0_empty_n;

assign do_adapt_U0_ap_continue = 1'b1;

assign do_adapt_U0_ap_start = ap_start;

assign ln_sm_read = do_adapt_U0_ln_sm_read;

assign matmul_step1_cache_window_U0_ap_continue = 1'b1;

assign matmul_step1_cache_window_U0_ap_start = start_for_matmul_step1_cache_window_U0_empty_n;

assign matmul_step2_mac_U0_ap_continue = 1'b1;

assign matmul_step2_mac_U0_ap_start = start_for_matmul_step2_mac_U0_empty_n;

assign o_stream_TDATA = do_adapt_1_U0_o_stream_TDATA;

assign o_stream_TVALID = do_adapt_1_U0_o_stream_TVALID;

assign start_for_do_adapt_1_U0_din = 1'b1;

assign start_for_matmul_step1_cache_window_U0_din = 1'b1;

assign start_for_matmul_step2_mac_U0_din = 1'b1;

endmodule //HEAD_do_matmul
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_fifo_w13_d2_S
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 13,
    ADDR_WIDTH   = 2,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 
    output wire [ADDR_WIDTH:0]   if_num_data_valid, // for FRP
    output wire [ADDR_WIDTH:0]   if_fifo_cap,       // for FRP

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid? 
    reg  [ADDR_WIDTH:0]   num_data_valid; //yes 
//------------------------Instantiation------------------
    HEAD_fifo_w13_d2_S_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_fifo_w13_d2_S_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 
    assign if_num_data_valid = num_data_valid;
    assign if_fifo_cap       = DEPTH;

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 
    always @(posedge clk) begin
        if (reset)
            num_data_valid <= {ADDR_WIDTH+1{1'b0}};
        else if ( push & ~pop)
            num_data_valid <= num_data_valid + 1;
        else if (~push & pop)
            num_data_valid <= num_data_valid - 1;
    end // 

endmodule  


module HEAD_fifo_w13_d2_S_ShiftReg
#(parameter
    DATA_WIDTH  = 13,
    ADDR_WIDTH  = 2,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_fifo_w76_d2_S
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 76,
    ADDR_WIDTH   = 2,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 
    output wire [ADDR_WIDTH:0]   if_num_data_valid, // for FRP
    output wire [ADDR_WIDTH:0]   if_fifo_cap,       // for FRP

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid? 
    reg  [ADDR_WIDTH:0]   num_data_valid; //yes 
//------------------------Instantiation------------------
    HEAD_fifo_w76_d2_S_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_fifo_w76_d2_S_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 
    assign if_num_data_valid = num_data_valid;
    assign if_fifo_cap       = DEPTH;

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 
    always @(posedge clk) begin
        if (reset)
            num_data_valid <= {ADDR_WIDTH+1{1'b0}};
        else if ( push & ~pop)
            num_data_valid <= num_data_valid + 1;
        else if (~push & pop)
            num_data_valid <= num_data_valid - 1;
    end // 

endmodule  


module HEAD_fifo_w76_d2_S_ShiftReg
#(parameter
    DATA_WIDTH  = 76,
    ADDR_WIDTH  = 2,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_fifo_w8_d2_S
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 8,
    ADDR_WIDTH   = 2,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 
    output wire [ADDR_WIDTH:0]   if_num_data_valid, // for FRP
    output wire [ADDR_WIDTH:0]   if_fifo_cap,       // for FRP

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid? 
    reg  [ADDR_WIDTH:0]   num_data_valid; //yes 
//------------------------Instantiation------------------
    HEAD_fifo_w8_d2_S_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_fifo_w8_d2_S_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 
    assign if_num_data_valid = num_data_valid;
    assign if_fifo_cap       = DEPTH;

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 
    always @(posedge clk) begin
        if (reset)
            num_data_valid <= {ADDR_WIDTH+1{1'b0}};
        else if ( push & ~pop)
            num_data_valid <= num_data_valid + 1;
        else if (~push & pop)
            num_data_valid <= num_data_valid - 1;
    end // 

endmodule  


module HEAD_fifo_w8_d2_S_ShiftReg
#(parameter
    DATA_WIDTH  = 8,
    ADDR_WIDTH  = 2,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_fifo_w8_d2_S_x
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 8,
    ADDR_WIDTH   = 2,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 
    output wire [ADDR_WIDTH:0]   if_num_data_valid, // for FRP
    output wire [ADDR_WIDTH:0]   if_fifo_cap,       // for FRP

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid? 
    reg  [ADDR_WIDTH:0]   num_data_valid; //yes 
//------------------------Instantiation------------------
    HEAD_fifo_w8_d2_S_x_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_fifo_w8_d2_S_x_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 
    assign if_num_data_valid = num_data_valid;
    assign if_fifo_cap       = DEPTH;

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 
    always @(posedge clk) begin
        if (reset)
            num_data_valid <= {ADDR_WIDTH+1{1'b0}};
        else if ( push & ~pop)
            num_data_valid <= num_data_valid + 1;
        else if (~push & pop)
            num_data_valid <= num_data_valid - 1;
    end // 

endmodule  


module HEAD_fifo_w8_d2_S_x_ShiftReg
#(parameter
    DATA_WIDTH  = 8,
    ADDR_WIDTH  = 2,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)
// Tool Version Limit: 2023.10
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// 
// ==============================================================

`timescale 1 ns / 1 ps

module HEAD_flow_control_loop_pipe(
        ap_clk,
        ap_rst,
        ap_start,
        ap_ready,
        ap_done,
        ap_continue,
        ap_start_int,
        ap_ready_int,
        ap_done_int,
        ap_continue_int,
        ap_loop_init,
        ap_loop_exit_ready,
        ap_loop_exit_done
);

input   ap_clk;
input   ap_rst;

//Block level handshake with outside loop
input   ap_start;
output  ap_ready;
output  ap_done;
input   ap_continue;

//Block level handshake with loop body
output  ap_start_int;
input   ap_ready_int;
input   ap_done_int;
output  ap_continue_int;

//Init live in variables
output   ap_loop_init;
reg ap_loop_init;

//Exit signal from loop body
input   ap_loop_exit_ready;
input   ap_loop_exit_done;

// power-on initialization
initial begin
//#0 ap_loop_init = 1'b1;
end

assign ap_start_int = ap_start;

assign ap_continue_int = ap_continue;

assign ap_done = ap_loop_exit_done;

assign ap_ready = ap_loop_exit_ready;

//ap_loop_init is valid for the first II
//of the first loop run so as to enable
//the init block ops which are pushed into
//the first state of the pipeline region
always @ (posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_loop_init <= 1'b1;
    end else if(ap_loop_exit_ready == 1'b1) begin
        ap_loop_init <= 1'b1;
    end else if(ap_ready_int == 1'b1) begin
        ap_loop_init <= 1'b0;
    end
end

endmodule
        
// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)
// Tool Version Limit: 2023.10
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// 
// ==============================================================
`timescale 1 ns / 1 ps

module HEAD_mac_muladd_15ns_16ns_23ns_30_4_1_DSP48_0(
    input clk,
    input rst,
    input ce,
    input  [15 - 1:0] in0,
    input  [16 - 1:0] in1,
    input  [23 - 1:0] in2,
    output [30 - 1:0]  dout);

wire signed [27 - 1:0]     a;
wire signed [24 - 1:0]     b;
wire signed [58 - 1:0]     c;
wire signed [51 - 1:0]     m;
wire signed [58 - 1:0]     p;
reg  signed [51 - 1:0]     m_reg;
reg  signed [27 - 1:0]     a_reg;
reg  signed [24 - 1:0]     b_reg;
reg  signed [58 - 1:0]     p_reg;

assign a  = $unsigned(in0);
assign b  = $unsigned(in1);
assign c  = $unsigned(in2);

assign m  = a_reg * b_reg;
assign p  = m_reg + c;

always @(posedge clk) begin
    if (ce) begin
        m_reg  <= m;
        a_reg  <= a;
        b_reg  <= b;
        p_reg  <= p;
    end
end

assign dout = p_reg;

endmodule
`timescale 1 ns / 1 ps
module HEAD_mac_muladd_15ns_16ns_23ns_30_4_1(
    clk,
    reset,
    ce,
    din0,
    din1,
    din2,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter din2_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
input[din2_WIDTH - 1:0] din2;
output[dout_WIDTH - 1:0] dout;



HEAD_mac_muladd_15ns_16ns_23ns_30_4_1_DSP48_0 HEAD_mac_muladd_15ns_16ns_23ns_30_4_1_DSP48_0_U(
    .clk( clk ),
    .rst( reset ),
    .ce( ce ),
    .in0( din0 ),
    .in1( din1 ),
    .in2( din2 ),
    .dout( dout ));

endmodule

// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)
// Tool Version Limit: 2023.10
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// 
// ==============================================================
`timescale 1 ns / 1 ps

module HEAD_mac_muladd_24s_16ns_35s_36_4_1_DSP48_1(
    input clk,
    input rst,
    input ce,
    input  [24 - 1:0] in0,
    input  [16 - 1:0] in1,
    input  [35 - 1:0] in2,
    output [36 - 1:0]  dout);

wire signed [27 - 1:0]     a;
wire signed [24 - 1:0]     b;
wire signed [58 - 1:0]     c;
wire signed [51 - 1:0]     m;
wire signed [58 - 1:0]     p;
reg  signed [51 - 1:0]     m_reg;
reg  signed [27 - 1:0]     a_reg;
reg  signed [24 - 1:0]     b_reg;
reg  signed [58 - 1:0]     p_reg;

assign a  = $signed(in0);
assign b  = $unsigned(in1);
assign c  = $signed(in2);

assign m  = a_reg * b_reg;
assign p  = m_reg + c;

always @(posedge clk) begin
    if (ce) begin
        m_reg  <= m;
        a_reg  <= a;
        b_reg  <= b;
        p_reg  <= p;
    end
end

assign dout = p_reg;

endmodule
`timescale 1 ns / 1 ps
module HEAD_mac_muladd_24s_16ns_35s_36_4_1(
    clk,
    reset,
    ce,
    din0,
    din1,
    din2,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter din2_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
input[din2_WIDTH - 1:0] din2;
output[dout_WIDTH - 1:0] dout;



HEAD_mac_muladd_24s_16ns_35s_36_4_1_DSP48_1 HEAD_mac_muladd_24s_16ns_35s_36_4_1_DSP48_1_U(
    .clk( clk ),
    .rst( reset ),
    .ce( ce ),
    .in0( din0 ),
    .in1( din1 ),
    .in2( din2 ),
    .dout( dout ));

endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_matmul_step1_cache_window (
        ap_clk,
        ap_rst,
        ap_start,
        start_full_n,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        adpt_sm_dout,
        adpt_sm_num_data_valid,
        adpt_sm_fifo_cap,
        adpt_sm_empty_n,
        adpt_sm_read,
        cache_window_sm_din,
        cache_window_sm_num_data_valid,
        cache_window_sm_fifo_cap,
        cache_window_sm_full_n,
        cache_window_sm_write,
        start_out,
        start_write
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
input   start_full_n;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input  [7:0] adpt_sm_dout;
input  [2:0] adpt_sm_num_data_valid;
input  [2:0] adpt_sm_fifo_cap;
input   adpt_sm_empty_n;
output   adpt_sm_read;
output  [7:0] cache_window_sm_din;
input  [2:0] cache_window_sm_num_data_valid;
input  [2:0] cache_window_sm_fifo_cap;
input   cache_window_sm_full_n;
output   cache_window_sm_write;
output   start_out;
output   start_write;

reg ap_idle;
reg adpt_sm_read;
reg cache_window_sm_write;
reg start_write;

reg    real_start;
reg    start_once_reg;
(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_enable_reg_pp0_iter2;
reg    ap_idle_pp0;
wire    internal_ap_ready;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [0:0] icmp_ln65_reg_309;
reg   [0:0] cmp10_reg_318;
reg    ap_predicate_op56_read_state2;
reg    ap_block_state2_pp0_stage0_iter1;
reg    ap_block_state3_pp0_stage0_iter2;
reg    ap_block_pp0_stage0_subdone;
wire   [0:0] icmp_ln65_fu_162_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    adpt_sm_blk_n;
wire    ap_block_pp0_stage0;
reg    cache_window_sm_blk_n;
reg    ap_block_pp0_stage0_11001;
reg   [0:0] icmp_ln65_reg_309_pp0_iter1_reg;
wire   [7:0] select_ln65_fu_192_p3;
reg   [7:0] select_ln65_reg_313;
wire   [0:0] cmp10_fu_208_p2;
reg   [0:0] cmp10_reg_318_pp0_iter1_reg;
reg   [7:0] wb_address0;
reg    wb_ce0;
reg    wb_we0;
wire   [7:0] wb_q0;
reg   [7:0] ap_phi_mux_vec_o_0_phi_fu_106_p4;
wire   [7:0] ap_phi_reg_pp0_iter0_vec_o_0_reg_103;
reg   [7:0] ap_phi_reg_pp0_iter1_vec_o_0_reg_103;
reg   [7:0] ap_phi_reg_pp0_iter2_vec_o_0_reg_103;
wire   [63:0] zext_ln66_fu_256_p1;
wire   [7:0] wb_addr_gep_fu_95_p3;
reg   [7:0] cit_fu_54;
wire   [7:0] add_ln66_fu_214_p2;
wire    ap_loop_init;
reg   [7:0] ap_sig_allocacmp_cit_load;
reg   [7:0] cot_fu_58;
wire   [7:0] select_ln65_1_fu_200_p3;
reg   [7:0] ap_sig_allocacmp_cot_load;
reg   [15:0] indvar_flatten_fu_62;
wire   [15:0] add_ln65_fu_156_p2;
reg   [15:0] ap_sig_allocacmp_indvar_flatten_load;
reg    ap_block_pp0_stage0_01001;
wire   [0:0] icmp_ln66_fu_186_p2;
wire   [7:0] cot_2_fu_180_p2;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
reg    ap_condition_144;
reg    ap_condition_142;
reg    ap_condition_263;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 start_once_reg = 1'b0;
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_enable_reg_pp0_iter2 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 cit_fu_54 = 8'd0;
//#0 cot_fu_58 = 8'd0;
//#0 indvar_flatten_fu_62 = 16'd0;
end

HEAD_matmul_step1_cache_window_wb_RAM_1P_LUTRAM_1R1W #(
    .DataWidth( 8 ),
    .AddressRange( 192 ),
    .AddressWidth( 8 ))
wb_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(wb_address0),
    .ce0(wb_ce0),
    .we0(wb_we0),
    .d0(adpt_sm_dout),
    .q0(wb_q0)
);

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(real_start),
    .ap_ready(internal_ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin
            ap_enable_reg_pp0_iter1 <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter2 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter2 <= ap_enable_reg_pp0_iter1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        start_once_reg <= 1'b0;
    end else begin
        if (((real_start == 1'b1) & (internal_ap_ready == 1'b0))) begin
            start_once_reg <= 1'b1;
        end else if ((internal_ap_ready == 1'b1)) begin
            start_once_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_144)) begin
        if (((cmp10_reg_318 == 1'd1) & (icmp_ln65_reg_309 == 1'd0))) begin
            ap_phi_reg_pp0_iter2_vec_o_0_reg_103 <= adpt_sm_dout;
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter2_vec_o_0_reg_103 <= ap_phi_reg_pp0_iter1_vec_o_0_reg_103;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_142)) begin
        if ((icmp_ln65_fu_162_p2 == 1'd0)) begin
            cit_fu_54 <= add_ln66_fu_214_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            cit_fu_54 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_142)) begin
        if ((icmp_ln65_fu_162_p2 == 1'd0)) begin
            cot_fu_58 <= select_ln65_1_fu_200_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            cot_fu_58 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_142)) begin
        if ((icmp_ln65_fu_162_p2 == 1'd0)) begin
            indvar_flatten_fu_62 <= add_ln65_fu_156_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            indvar_flatten_fu_62 <= 16'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        cmp10_reg_318 <= cmp10_fu_208_p2;
        cmp10_reg_318_pp0_iter1_reg <= cmp10_reg_318;
        icmp_ln65_reg_309 <= icmp_ln65_fu_162_p2;
        icmp_ln65_reg_309_pp0_iter1_reg <= icmp_ln65_reg_309;
        select_ln65_reg_313 <= select_ln65_fu_192_p3;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_phi_reg_pp0_iter1_vec_o_0_reg_103 <= ap_phi_reg_pp0_iter0_vec_o_0_reg_103;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_predicate_op56_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        adpt_sm_blk_n = adpt_sm_empty_n;
    end else begin
        adpt_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_predicate_op56_read_state2 == 1'b1) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        adpt_sm_read = 1'b1;
    end else begin
        adpt_sm_read = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln65_fu_162_p2 == 1'd1) & (1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_idle_pp0 == 1'b1) & (ap_start_int == 1'b0) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter2 == 1'b0) & (ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((cmp10_reg_318_pp0_iter1_reg == 1'd0) & (icmp_ln65_reg_309_pp0_iter1_reg == 1'd0))) begin
        ap_phi_mux_vec_o_0_phi_fu_106_p4 = wb_q0;
    end else begin
        ap_phi_mux_vec_o_0_phi_fu_106_p4 = ap_phi_reg_pp0_iter2_vec_o_0_reg_103;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_cit_load = 8'd0;
    end else begin
        ap_sig_allocacmp_cit_load = cit_fu_54;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_cot_load = 8'd0;
    end else begin
        ap_sig_allocacmp_cot_load = cot_fu_58;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_indvar_flatten_load = 16'd0;
    end else begin
        ap_sig_allocacmp_indvar_flatten_load = indvar_flatten_fu_62;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cache_window_sm_blk_n = cache_window_sm_full_n;
    end else begin
        cache_window_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cache_window_sm_write = 1'b1;
    end else begin
        cache_window_sm_write = 1'b0;
    end
end

always @ (*) begin
    if (((start_full_n == 1'b0) & (start_once_reg == 1'b0))) begin
        real_start = 1'b0;
    end else begin
        real_start = ap_start;
    end
end

always @ (*) begin
    if (((real_start == 1'b1) & (start_once_reg == 1'b0))) begin
        start_write = 1'b1;
    end else begin
        start_write = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_condition_263)) begin
        if ((cmp10_reg_318 == 1'd1)) begin
            wb_address0 = wb_addr_gep_fu_95_p3;
        end else if ((cmp10_reg_318 == 1'd0)) begin
            wb_address0 = zext_ln66_fu_256_p1;
        end else begin
            wb_address0 = 'bx;
        end
    end else begin
        wb_address0 = 'bx;
    end
end

always @ (*) begin
    if ((((1'b0 == ap_block_pp0_stage0_11001) & (cmp10_reg_318 == 1'd1) & (icmp_ln65_reg_309 == 1'd0) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0)) | ((1'b0 == ap_block_pp0_stage0_11001) & (cmp10_reg_318 == 1'd0) & (icmp_ln65_reg_309 == 1'd0) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0)))) begin
        wb_ce0 = 1'b1;
    end else begin
        wb_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (cmp10_reg_318 == 1'd1) & (icmp_ln65_reg_309 == 1'd0) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        wb_we0 = 1'b1;
    end else begin
        wb_we0 = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln65_fu_156_p2 = (ap_sig_allocacmp_indvar_flatten_load + 16'd1);

assign add_ln66_fu_214_p2 = (select_ln65_fu_192_p3 + 8'd1);

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_block_state2_pp0_stage0_iter1)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_done_reg == 1'b1);
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = ((ap_predicate_op56_read_state2 == 1'b1) & (1'b0 == adpt_sm_empty_n));
end

always @ (*) begin
    ap_block_state3_pp0_stage0_iter2 = (cache_window_sm_full_n == 1'b0);
end

always @ (*) begin
    ap_condition_142 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

always @ (*) begin
    ap_condition_144 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

always @ (*) begin
    ap_condition_263 = ((1'b0 == ap_block_pp0_stage0) & (icmp_ln65_reg_309 == 1'd0) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_phi_reg_pp0_iter0_vec_o_0_reg_103 = 'bx;

always @ (*) begin
    ap_predicate_op56_read_state2 = ((cmp10_reg_318 == 1'd1) & (icmp_ln65_reg_309 == 1'd0));
end

assign ap_ready = internal_ap_ready;

assign cache_window_sm_din = ap_phi_mux_vec_o_0_phi_fu_106_p4;

assign cmp10_fu_208_p2 = ((select_ln65_1_fu_200_p3 == 8'd0) ? 1'b1 : 1'b0);

assign cot_2_fu_180_p2 = (ap_sig_allocacmp_cot_load + 8'd1);

assign icmp_ln65_fu_162_p2 = ((ap_sig_allocacmp_indvar_flatten_load == 16'd48000) ? 1'b1 : 1'b0);

assign icmp_ln66_fu_186_p2 = ((ap_sig_allocacmp_cit_load == 8'd192) ? 1'b1 : 1'b0);

assign select_ln65_1_fu_200_p3 = ((icmp_ln66_fu_186_p2[0:0] == 1'b1) ? cot_2_fu_180_p2 : ap_sig_allocacmp_cot_load);

assign select_ln65_fu_192_p3 = ((icmp_ln66_fu_186_p2[0:0] == 1'b1) ? 8'd0 : ap_sig_allocacmp_cit_load);

assign start_out = real_start;

assign wb_addr_gep_fu_95_p3 = zext_ln66_fu_256_p1;

assign zext_ln66_fu_256_p1 = select_ln65_reg_313;

endmodule //HEAD_matmul_step1_cache_window
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_matmul_step1_cache_window_wb_RAM_1P_LUTRAM_1R1W (
     
    address0, ce0,
    d0, we0, 
    q0, 
     
    reset, clk);

parameter DataWidth = 8;
parameter AddressWidth = 8;
parameter AddressRange = 192;
 
input[AddressWidth-1:0] address0;
input ce0;
input[DataWidth-1:0] d0;
input we0; 
output reg[DataWidth-1:0] q0; 

input reset;
input clk;

(* ram_style = "distributed"  *)reg [DataWidth-1:0] ram[0:AddressRange-1];


 





//read first
always @(posedge clk)  
begin 
    if (ce0) begin
        if (we0) 
            ram[address0] <= d0; 
        q0 <= ram[address0];

    end
end 
 
 

endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_matmul_step2_mac (
        ap_clk,
        ap_rst,
        ap_start,
        start_full_n,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        cache_window_sm_dout,
        cache_window_sm_num_data_valid,
        cache_window_sm_fifo_cap,
        cache_window_sm_empty_n,
        cache_window_sm_read,
        mac_sm_din,
        mac_sm_num_data_valid,
        mac_sm_fifo_cap,
        mac_sm_full_n,
        mac_sm_write,
        start_out,
        start_write
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
input   start_full_n;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input  [7:0] cache_window_sm_dout;
input  [2:0] cache_window_sm_num_data_valid;
input  [2:0] cache_window_sm_fifo_cap;
input   cache_window_sm_empty_n;
output   cache_window_sm_read;
output  [75:0] mac_sm_din;
input  [2:0] mac_sm_num_data_valid;
input  [2:0] mac_sm_fifo_cap;
input   mac_sm_full_n;
output   mac_sm_write;
output   start_out;
output   start_write;

reg ap_idle;
reg cache_window_sm_read;
reg mac_sm_write;
reg start_write;

reg    real_start;
reg    start_once_reg;
(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_enable_reg_pp0_iter2;
reg    ap_enable_reg_pp0_iter3;
reg    ap_enable_reg_pp0_iter4;
reg    ap_idle_pp0;
wire    internal_ap_ready;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg    ap_block_state3_pp0_stage0_iter2;
reg   [0:0] icmp_ln161_reg_776;
reg   [0:0] icmp_ln161_reg_776_pp0_iter3_reg;
reg    ap_block_state5_pp0_stage0_iter4;
reg    ap_block_pp0_stage0_subdone;
wire   [0:0] icmp_ln121_fu_237_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [7:0] HEAD_INST_matmul_bias_arr_36_address0;
reg    HEAD_INST_matmul_bias_arr_36_ce0;
wire   [70:0] HEAD_INST_matmul_bias_arr_36_q0;
wire   [15:0] HEAD_INST_matmul_weight_arr_35_address0;
reg    HEAD_INST_matmul_weight_arr_35_ce0;
wire   [31:0] HEAD_INST_matmul_weight_arr_35_q0;
reg    cache_window_sm_blk_n;
wire    ap_block_pp0_stage0;
reg    mac_sm_blk_n;
reg    ap_block_pp0_stage0_11001;
wire   [7:0] select_ln121_fu_267_p3;
reg   [7:0] select_ln121_reg_747;
wire   [7:0] select_ln121_1_fu_275_p3;
reg   [7:0] select_ln121_1_reg_753;
reg   [7:0] select_ln121_1_reg_753_pp0_iter1_reg;
wire   [15:0] add_ln151_fu_313_p2;
reg   [15:0] add_ln151_reg_758;
wire   [0:0] icmp_ln126_fu_365_p2;
reg   [0:0] icmp_ln126_reg_768;
reg   [0:0] icmp_ln126_reg_768_pp0_iter2_reg;
reg   [0:0] icmp_ln126_reg_768_pp0_iter3_reg;
wire   [0:0] icmp_ln161_fu_374_p2;
reg   [0:0] icmp_ln161_reg_776_pp0_iter2_reg;
reg   [7:0] cache_window_sm_read_reg_785;
wire   [7:0] trunc_ln151_fu_389_p1;
reg  signed [7:0] trunc_ln151_reg_790;
reg  signed [7:0] tmp_s_reg_795;
reg  signed [7:0] tmp_4_reg_800;
reg  signed [7:0] tmp_5_reg_805;
reg   [70:0] HEAD_INST_matmul_bias_arr_36_load_reg_810;
wire  signed [15:0] mul_res_fu_437_p2;
reg  signed [15:0] mul_res_reg_818;
wire  signed [15:0] mul_res_1_fu_454_p2;
reg  signed [15:0] mul_res_1_reg_823;
wire  signed [15:0] mul_res_2_fu_471_p2;
reg  signed [15:0] mul_res_2_reg_828;
wire  signed [15:0] mul_res_3_fu_488_p2;
reg  signed [15:0] mul_res_3_reg_833;
wire   [63:0] zext_ln151_2_fu_361_p1;
wire   [63:0] zext_ln121_fu_379_p1;
reg   [7:0] cit_fu_122;
wire   [7:0] add_ln122_fu_319_p2;
wire    ap_loop_init;
reg   [7:0] ap_sig_allocacmp_cit_load;
reg   [18:0] p_0_0_037_fu_126;
wire   [18:0] add_ln153_fu_583_p2;
reg   [18:0] p_0_0_0_139_fu_130;
wire   [18:0] add_ln153_1_fu_592_p2;
reg   [18:0] p_0_0_0_241_fu_134;
wire   [18:0] add_ln153_2_fu_601_p2;
reg   [18:0] p_0_0_0_343_fu_138;
wire   [18:0] add_ln153_3_fu_610_p2;
reg   [7:0] cot_fu_142;
reg   [7:0] ap_sig_allocacmp_cot_load;
reg   [15:0] indvar_flatten_fu_146;
wire   [15:0] add_ln121_1_fu_231_p2;
reg   [15:0] ap_sig_allocacmp_indvar_flatten_load;
reg    ap_block_pp0_stage0_01001;
wire   [0:0] icmp_ln122_fu_261_p2;
wire   [7:0] add_ln121_fu_255_p2;
wire   [13:0] tmp_9_fu_291_p3;
wire   [15:0] tmp_3_fu_283_p3;
wire   [15:0] zext_ln151_fu_299_p1;
wire   [15:0] sub_ln151_fu_303_p2;
wire   [15:0] zext_ln151_1_fu_309_p1;
wire  signed [7:0] mul_res_fu_437_p1;
wire  signed [15:0] sext_ln151_fu_423_p1;
wire  signed [7:0] mul_res_1_fu_454_p1;
wire  signed [7:0] mul_res_2_fu_471_p1;
wire  signed [7:0] mul_res_3_fu_488_p1;
wire   [13:0] tmp_8_fu_539_p4;
wire  signed [18:0] sext_ln131_fu_548_p1;
wire   [18:0] tmp_2_fu_530_p4;
wire   [18:0] tmp_1_fu_521_p4;
wire   [18:0] trunc_ln131_fu_518_p1;
wire   [18:0] select_ln126_3_fu_573_p3;
wire  signed [18:0] sext_ln153_fu_580_p1;
wire   [18:0] select_ln126_2_fu_566_p3;
wire  signed [18:0] sext_ln153_1_fu_589_p1;
wire   [18:0] select_ln126_1_fu_559_p3;
wire  signed [18:0] sext_ln153_2_fu_598_p1;
wire   [18:0] select_ln126_fu_552_p3;
wire  signed [18:0] sext_ln153_3_fu_607_p1;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg    ap_loop_exit_ready_pp0_iter2_reg;
reg    ap_loop_exit_ready_pp0_iter3_reg;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
reg    ap_condition_207;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 start_once_reg = 1'b0;
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_enable_reg_pp0_iter2 = 1'b0;
//#0 ap_enable_reg_pp0_iter3 = 1'b0;
//#0 ap_enable_reg_pp0_iter4 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 cit_fu_122 = 8'd0;
//#0 p_0_0_037_fu_126 = 19'd0;
//#0 p_0_0_0_139_fu_130 = 19'd0;
//#0 p_0_0_0_241_fu_134 = 19'd0;
//#0 p_0_0_0_343_fu_138 = 19'd0;
//#0 cot_fu_142 = 8'd0;
//#0 indvar_flatten_fu_146 = 16'd0;
end

HEAD_matmul_step2_mac_HEAD_INST_matmul_bias_arr_36_ROM_1P_LUTRAM_1R #(
    .DataWidth( 71 ),
    .AddressRange( 250 ),
    .AddressWidth( 8 ))
HEAD_INST_matmul_bias_arr_36_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(HEAD_INST_matmul_bias_arr_36_address0),
    .ce0(HEAD_INST_matmul_bias_arr_36_ce0),
    .q0(HEAD_INST_matmul_bias_arr_36_q0)
);

HEAD_matmul_step2_mac_HEAD_INST_matmul_weight_arr_35_ROM_1P_BRAM_1R #(
    .DataWidth( 32 ),
    .AddressRange( 48000 ),
    .AddressWidth( 16 ))
HEAD_INST_matmul_weight_arr_35_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(HEAD_INST_matmul_weight_arr_35_address0),
    .ce0(HEAD_INST_matmul_weight_arr_35_ce0),
    .q0(HEAD_INST_matmul_weight_arr_35_q0)
);

HEAD_mul_8s_8s_16_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 8 ),
    .dout_WIDTH( 16 ))
mul_8s_8s_16_1_1_U23(
    .din0(trunc_ln151_reg_790),
    .din1(mul_res_fu_437_p1),
    .dout(mul_res_fu_437_p2)
);

HEAD_mul_8s_8s_16_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 8 ),
    .dout_WIDTH( 16 ))
mul_8s_8s_16_1_1_U24(
    .din0(tmp_s_reg_795),
    .din1(mul_res_1_fu_454_p1),
    .dout(mul_res_1_fu_454_p2)
);

HEAD_mul_8s_8s_16_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 8 ),
    .dout_WIDTH( 16 ))
mul_8s_8s_16_1_1_U25(
    .din0(tmp_4_reg_800),
    .din1(mul_res_2_fu_471_p1),
    .dout(mul_res_2_fu_471_p2)
);

HEAD_mul_8s_8s_16_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 8 ),
    .dout_WIDTH( 16 ))
mul_8s_8s_16_1_1_U26(
    .din0(tmp_5_reg_805),
    .din1(mul_res_3_fu_488_p1),
    .dout(mul_res_3_fu_488_p2)
);

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(real_start),
    .ap_ready(internal_ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter3_reg == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin
            ap_enable_reg_pp0_iter1 <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter2 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter2 <= ap_enable_reg_pp0_iter1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter3 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter3 <= ap_enable_reg_pp0_iter2;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter4 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter4 <= ap_enable_reg_pp0_iter3;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        start_once_reg <= 1'b0;
    end else begin
        if (((real_start == 1'b1) & (internal_ap_ready == 1'b0))) begin
            start_once_reg <= 1'b1;
        end else if ((internal_ap_ready == 1'b1)) begin
            start_once_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_207)) begin
        if ((icmp_ln121_fu_237_p2 == 1'd0)) begin
            cit_fu_122 <= add_ln122_fu_319_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            cit_fu_122 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_207)) begin
        if ((icmp_ln121_fu_237_p2 == 1'd0)) begin
            cot_fu_142 <= select_ln121_1_fu_275_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            cot_fu_142 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_207)) begin
        if ((icmp_ln121_fu_237_p2 == 1'd0)) begin
            indvar_flatten_fu_146 <= add_ln121_1_fu_231_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            indvar_flatten_fu_146 <= 16'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b0 == ap_block_pp0_stage0_11001)) begin
        HEAD_INST_matmul_bias_arr_36_load_reg_810 <= HEAD_INST_matmul_bias_arr_36_q0;
        ap_loop_exit_ready_pp0_iter3_reg <= ap_loop_exit_ready_pp0_iter2_reg;
        cache_window_sm_read_reg_785 <= cache_window_sm_dout;
        icmp_ln126_reg_768_pp0_iter2_reg <= icmp_ln126_reg_768;
        icmp_ln126_reg_768_pp0_iter3_reg <= icmp_ln126_reg_768_pp0_iter2_reg;
        icmp_ln161_reg_776_pp0_iter2_reg <= icmp_ln161_reg_776;
        icmp_ln161_reg_776_pp0_iter3_reg <= icmp_ln161_reg_776_pp0_iter2_reg;
        mul_res_1_reg_823 <= mul_res_1_fu_454_p2;
        mul_res_2_reg_828 <= mul_res_2_fu_471_p2;
        mul_res_3_reg_833 <= mul_res_3_fu_488_p2;
        mul_res_reg_818 <= mul_res_fu_437_p2;
        tmp_4_reg_800 <= {{HEAD_INST_matmul_weight_arr_35_q0[23:16]}};
        tmp_5_reg_805 <= {{HEAD_INST_matmul_weight_arr_35_q0[31:24]}};
        tmp_s_reg_795 <= {{HEAD_INST_matmul_weight_arr_35_q0[15:8]}};
        trunc_ln151_reg_790 <= trunc_ln151_fu_389_p1;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        add_ln151_reg_758 <= add_ln151_fu_313_p2;
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        ap_loop_exit_ready_pp0_iter2_reg <= ap_loop_exit_ready_pp0_iter1_reg;
        icmp_ln126_reg_768 <= icmp_ln126_fu_365_p2;
        icmp_ln161_reg_776 <= icmp_ln161_fu_374_p2;
        select_ln121_1_reg_753 <= select_ln121_1_fu_275_p3;
        select_ln121_1_reg_753_pp0_iter1_reg <= select_ln121_1_reg_753;
        select_ln121_reg_747 <= select_ln121_fu_267_p3;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter4 == 1'b1))) begin
        p_0_0_037_fu_126 <= add_ln153_fu_583_p2;
        p_0_0_0_139_fu_130 <= add_ln153_1_fu_592_p2;
        p_0_0_0_241_fu_134 <= add_ln153_2_fu_601_p2;
        p_0_0_0_343_fu_138 <= add_ln153_3_fu_610_p2;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        HEAD_INST_matmul_bias_arr_36_ce0 = 1'b1;
    end else begin
        HEAD_INST_matmul_bias_arr_36_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        HEAD_INST_matmul_weight_arr_35_ce0 = 1'b1;
    end else begin
        HEAD_INST_matmul_weight_arr_35_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln121_fu_237_p2 == 1'd1) & (1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_loop_exit_ready_pp0_iter3_reg == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (ap_idle_pp0 == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter4 == 1'b0) & (ap_enable_reg_pp0_iter3 == 1'b0) & (ap_enable_reg_pp0_iter2 == 1'b0) & (ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_cit_load = 8'd0;
    end else begin
        ap_sig_allocacmp_cit_load = cit_fu_122;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_cot_load = 8'd0;
    end else begin
        ap_sig_allocacmp_cot_load = cot_fu_142;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_sig_allocacmp_indvar_flatten_load = 16'd0;
    end else begin
        ap_sig_allocacmp_indvar_flatten_load = indvar_flatten_fu_146;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cache_window_sm_blk_n = cache_window_sm_empty_n;
    end else begin
        cache_window_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cache_window_sm_read = 1'b1;
    end else begin
        cache_window_sm_read = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (icmp_ln161_reg_776_pp0_iter3_reg == 1'd1) & (ap_enable_reg_pp0_iter4 == 1'b1))) begin
        mac_sm_blk_n = mac_sm_full_n;
    end else begin
        mac_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (icmp_ln161_reg_776_pp0_iter3_reg == 1'd1) & (ap_enable_reg_pp0_iter4 == 1'b1))) begin
        mac_sm_write = 1'b1;
    end else begin
        mac_sm_write = 1'b0;
    end
end

always @ (*) begin
    if (((start_full_n == 1'b0) & (start_once_reg == 1'b0))) begin
        real_start = 1'b0;
    end else begin
        real_start = ap_start;
    end
end

always @ (*) begin
    if (((real_start == 1'b1) & (start_once_reg == 1'b0))) begin
        start_write = 1'b1;
    end else begin
        start_write = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign HEAD_INST_matmul_bias_arr_36_address0 = zext_ln121_fu_379_p1;

assign HEAD_INST_matmul_weight_arr_35_address0 = zext_ln151_2_fu_361_p1;

assign add_ln121_1_fu_231_p2 = (ap_sig_allocacmp_indvar_flatten_load + 16'd1);

assign add_ln121_fu_255_p2 = (ap_sig_allocacmp_cot_load + 8'd1);

assign add_ln122_fu_319_p2 = (select_ln121_fu_267_p3 + 8'd1);

assign add_ln151_fu_313_p2 = (sub_ln151_fu_303_p2 + zext_ln151_1_fu_309_p1);

assign add_ln153_1_fu_592_p2 = ($signed(select_ln126_2_fu_566_p3) + $signed(sext_ln153_1_fu_589_p1));

assign add_ln153_2_fu_601_p2 = ($signed(select_ln126_1_fu_559_p3) + $signed(sext_ln153_2_fu_598_p1));

assign add_ln153_3_fu_610_p2 = ($signed(select_ln126_fu_552_p3) + $signed(sext_ln153_3_fu_607_p1));

assign add_ln153_fu_583_p2 = ($signed(select_ln126_3_fu_573_p3) + $signed(sext_ln153_fu_580_p1));

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter4 == 1'b1) & (1'b1 == ap_block_state5_pp0_stage0_iter4)) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter4 == 1'b1) & (1'b1 == ap_block_state5_pp0_stage0_iter4)) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter4 == 1'b1) & (1'b1 == ap_block_state5_pp0_stage0_iter4)) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_done_reg == 1'b1);
end

always @ (*) begin
    ap_block_state3_pp0_stage0_iter2 = (cache_window_sm_empty_n == 1'b0);
end

always @ (*) begin
    ap_block_state5_pp0_stage0_iter4 = ((icmp_ln161_reg_776_pp0_iter3_reg == 1'd1) & (mac_sm_full_n == 1'b0));
end

always @ (*) begin
    ap_condition_207 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_ready = internal_ap_ready;

assign icmp_ln121_fu_237_p2 = ((ap_sig_allocacmp_indvar_flatten_load == 16'd48000) ? 1'b1 : 1'b0);

assign icmp_ln122_fu_261_p2 = ((ap_sig_allocacmp_cit_load == 8'd192) ? 1'b1 : 1'b0);

assign icmp_ln126_fu_365_p2 = ((select_ln121_reg_747 == 8'd0) ? 1'b1 : 1'b0);

assign icmp_ln161_fu_374_p2 = ((select_ln121_reg_747 == 8'd191) ? 1'b1 : 1'b0);

assign mac_sm_din = {{{{add_ln153_3_fu_610_p2}, {add_ln153_2_fu_601_p2}}, {add_ln153_1_fu_592_p2}}, {add_ln153_fu_583_p2}};

assign mul_res_1_fu_454_p1 = sext_ln151_fu_423_p1;

assign mul_res_2_fu_471_p1 = sext_ln151_fu_423_p1;

assign mul_res_3_fu_488_p1 = sext_ln151_fu_423_p1;

assign mul_res_fu_437_p1 = sext_ln151_fu_423_p1;

assign select_ln121_1_fu_275_p3 = ((icmp_ln122_fu_261_p2[0:0] == 1'b1) ? add_ln121_fu_255_p2 : ap_sig_allocacmp_cot_load);

assign select_ln121_fu_267_p3 = ((icmp_ln122_fu_261_p2[0:0] == 1'b1) ? 8'd0 : ap_sig_allocacmp_cit_load);

assign select_ln126_1_fu_559_p3 = ((icmp_ln126_reg_768_pp0_iter3_reg[0:0] == 1'b1) ? tmp_2_fu_530_p4 : p_0_0_0_241_fu_134);

assign select_ln126_2_fu_566_p3 = ((icmp_ln126_reg_768_pp0_iter3_reg[0:0] == 1'b1) ? tmp_1_fu_521_p4 : p_0_0_0_139_fu_130);

assign select_ln126_3_fu_573_p3 = ((icmp_ln126_reg_768_pp0_iter3_reg[0:0] == 1'b1) ? trunc_ln131_fu_518_p1 : p_0_0_037_fu_126);

assign select_ln126_fu_552_p3 = ((icmp_ln126_reg_768_pp0_iter3_reg[0:0] == 1'b1) ? sext_ln131_fu_548_p1 : p_0_0_0_343_fu_138);

assign sext_ln131_fu_548_p1 = $signed(tmp_8_fu_539_p4);

assign sext_ln151_fu_423_p1 = $signed(cache_window_sm_read_reg_785);

assign sext_ln153_1_fu_589_p1 = mul_res_1_reg_823;

assign sext_ln153_2_fu_598_p1 = mul_res_2_reg_828;

assign sext_ln153_3_fu_607_p1 = mul_res_3_reg_833;

assign sext_ln153_fu_580_p1 = mul_res_reg_818;

assign start_out = real_start;

assign sub_ln151_fu_303_p2 = (tmp_3_fu_283_p3 - zext_ln151_fu_299_p1);

assign tmp_1_fu_521_p4 = {{HEAD_INST_matmul_bias_arr_36_load_reg_810[37:19]}};

assign tmp_2_fu_530_p4 = {{HEAD_INST_matmul_bias_arr_36_load_reg_810[56:38]}};

assign tmp_3_fu_283_p3 = {{select_ln121_1_fu_275_p3}, {8'd0}};

assign tmp_8_fu_539_p4 = {{HEAD_INST_matmul_bias_arr_36_load_reg_810[70:57]}};

assign tmp_9_fu_291_p3 = {{select_ln121_1_fu_275_p3}, {6'd0}};

assign trunc_ln131_fu_518_p1 = HEAD_INST_matmul_bias_arr_36_load_reg_810[18:0];

assign trunc_ln151_fu_389_p1 = HEAD_INST_matmul_weight_arr_35_q0[7:0];

assign zext_ln121_fu_379_p1 = select_ln121_1_reg_753_pp0_iter1_reg;

assign zext_ln151_1_fu_309_p1 = select_ln121_fu_267_p3;

assign zext_ln151_2_fu_361_p1 = add_ln151_reg_758;

assign zext_ln151_fu_299_p1 = tmp_9_fu_291_p3;

endmodule //HEAD_matmul_step2_mac
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_matmul_step2_mac_HEAD_INST_matmul_bias_arr_36_ROM_1P_LUTRAM_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 71;
parameter AddressWidth = 8;
parameter AddressRange = 250;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
(* rom_style = "distributed" *)reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("C:/projects/AAAProjects/PROJ06_PyHLS_ViT/SPINAL/src/main/verilog/HEAD/HEAD_matmul_step2_mac_HEAD_INST_matmul_bias_arr_36_ROM_1P_LUTRAM_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module HEAD_matmul_step2_mac_HEAD_INST_matmul_weight_arr_35_ROM_1P_BRAM_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 32;
parameter AddressWidth = 16;
parameter AddressRange = 48000;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
(* rom_style = "block" *)reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("C:/projects/AAAProjects/PROJ06_PyHLS_ViT/SPINAL/src/main/verilog/HEAD/HEAD_matmul_step2_mac_HEAD_INST_matmul_weight_arr_35_ROM_1P_BRAM_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1 ns / 1 ps

  module HEAD_mul_13s_11ns_24_2_1(clk,ce,reset,din0, din1, dout);
parameter ID = 1;
parameter NUM_STAGE = 0;
parameter din0_WIDTH = 14;
parameter din1_WIDTH = 12;
parameter dout_WIDTH = 26;

input clk;
input ce;
input reset;

input [din0_WIDTH - 1 : 0] din0; 
input [din1_WIDTH - 1 : 0] din1; 
output [dout_WIDTH - 1 : 0] dout;

wire signed [dout_WIDTH - 1 : 0] tmp_product;


reg signed [dout_WIDTH - 1 : 0] buff0;











assign tmp_product = $signed(din0) * $signed({1'b0, din1});







always @(posedge clk)
begin
    if (ce) begin
        buff0 <= tmp_product;





    end
end




assign dout = buff0;






endmodule
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1 ns / 1 ps

  (* use_dsp = "yes" *)  module HEAD_mul_13s_13s_24_2_1(clk,ce,reset,din0, din1, dout);
parameter ID = 1;
parameter NUM_STAGE = 0;
parameter din0_WIDTH = 14;
parameter din1_WIDTH = 12;
parameter dout_WIDTH = 26;

input clk;
input ce;
input reset;

input [din0_WIDTH - 1 : 0] din0; 
input [din1_WIDTH - 1 : 0] din1; 
output [dout_WIDTH - 1 : 0] dout;

wire signed [dout_WIDTH - 1 : 0] tmp_product;


reg signed [dout_WIDTH - 1 : 0] buff0;












assign tmp_product = $signed(din0) * $signed(din1);






always @(posedge clk)
begin
    if (ce) begin
        buff0 <= tmp_product;





    end
end




assign dout = buff0;






endmodule
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1 ns / 1 ps

  (* use_dsp = "no" *)  module HEAD_mul_8s_8s_16_1_1(din0, din1, dout);
parameter ID = 1;
parameter NUM_STAGE = 0;
parameter din0_WIDTH = 14;
parameter din1_WIDTH = 12;
parameter dout_WIDTH = 26;

input [din0_WIDTH - 1 : 0] din0; 
input [din1_WIDTH - 1 : 0] din1; 
output [dout_WIDTH - 1 : 0] dout;

wire signed [dout_WIDTH - 1 : 0] tmp_product;













assign tmp_product = $signed(din0) * $signed(din1);








assign dout = tmp_product;







endmodule
// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)
// Tool Version Limit: 2023.10
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// 
// ==============================================================

`timescale 1ns/1ps

module HEAD_regslice_both
#(parameter 
    DataWidth=32
)(
    input ap_clk ,
    input ap_rst,

    input [DataWidth-1:0] data_in , 
    input vld_in , 
    output ack_in ,
    output [DataWidth-1:0] data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);
 

reg   [1:0] B_V_data_1_state;
wire   [DataWidth-1:0] B_V_data_1_data_in;
reg   [DataWidth-1:0] B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg   [DataWidth-1:0] B_V_data_1_payload_A;
reg   [DataWidth-1:0] B_V_data_1_payload_B;
reg    B_V_data_1_sel_rd;
reg    B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both

module HEAD_regslice_both_w1
#(parameter 
    DataWidth=1
)(
    input ap_clk ,
    input ap_rst,

    input data_in , 
    input vld_in , 
    output ack_in ,
    output data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);

reg     [1:0] B_V_data_1_state;
wire    B_V_data_1_data_in;
reg     B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg     B_V_data_1_payload_A;
reg     B_V_data_1_payload_B;
reg     B_V_data_1_sel_rd;
reg     B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both


// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps 

module HEAD_select_cls (
        ap_clk,
        ap_rst,
        ap_start,
        start_full_n,
        ap_done,
        ap_continue,
        ap_idle,
        ap_ready,
        i_stream_TVALID,
        cls_sm_din,
        cls_sm_num_data_valid,
        cls_sm_fifo_cap,
        cls_sm_full_n,
        cls_sm_write,
        start_out,
        start_write,
        i_stream_TDATA,
        i_stream_TREADY
);

parameter    ap_ST_fsm_pp0_stage0 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
input   start_full_n;
output   ap_done;
input   ap_continue;
output   ap_idle;
output   ap_ready;
input   i_stream_TVALID;
output  [12:0] cls_sm_din;
input  [2:0] cls_sm_num_data_valid;
input  [2:0] cls_sm_fifo_cap;
input   cls_sm_full_n;
output   cls_sm_write;
output   start_out;
output   start_write;
input  [31:0] i_stream_TDATA;
output   i_stream_TREADY;

reg ap_idle;
reg cls_sm_write;
reg start_write;

reg    real_start;
reg    start_once_reg;
(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_pp0_stage0;
wire    ap_enable_reg_pp0_iter0;
reg    ap_enable_reg_pp0_iter1;
reg    ap_enable_reg_pp0_iter2;
reg    ap_idle_pp0;
wire    internal_ap_ready;
wire   [0:0] icmp_ln113_fu_129_p2;
reg    ap_done_reg;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [0:0] cmp6_reg_270;
reg    ap_block_state3_pp0_stage0_iter2;
reg    ap_block_pp0_stage0_subdone;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    i_stream_TDATA_blk_n;
wire    ap_block_pp0_stage0;
reg    cls_sm_blk_n;
reg    ap_block_pp0_stage0_11001;
wire   [6:0] select_ln113_fu_153_p3;
reg   [6:0] select_ln113_reg_259;
wire   [12:0] trunc_ln118_fu_163_p1;
reg   [12:0] trunc_ln118_reg_264;
reg   [12:0] trunc_ln118_reg_264_pp0_iter1_reg;
wire   [0:0] cmp6_fu_217_p2;
reg   [7:0] ciat_fu_50;
wire   [7:0] ciat_3_fu_173_p3;
wire    ap_loop_init;
reg   [7:0] ap_sig_allocacmp_ciat_2;
reg   [6:0] tt_fu_54;
reg   [6:0] ap_sig_allocacmp_tt_load;
reg   [14:0] indvar_flatten_fu_58;
wire   [14:0] add_ln113_fu_123_p2;
reg   [14:0] ap_sig_allocacmp_indvar_flatten_load;
reg    ap_block_pp0_stage0_01001;
wire   [0:0] icmp_ln114_fu_147_p2;
wire   [6:0] tt_2_fu_141_p2;
wire   [7:0] add_ln114_fu_167_p2;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg   [0:0] ap_NS_fsm;
wire    ap_enable_pp0;
wire    ap_start_int;
wire    regslice_both_i_stream_U_apdone_blk;
wire   [31:0] i_stream_TDATA_int_regslice;
wire    i_stream_TVALID_int_regslice;
reg    i_stream_TREADY_int_regslice;
wire    regslice_both_i_stream_U_ack_in;
reg    ap_condition_124;
wire    ap_ce_reg;

// power-on initialization
initial begin
//#0 start_once_reg = 1'b0;
//#0 ap_CS_fsm = 1'd1;
//#0 ap_enable_reg_pp0_iter1 = 1'b0;
//#0 ap_enable_reg_pp0_iter2 = 1'b0;
//#0 ap_done_reg = 1'b0;
//#0 ciat_fu_50 = 8'd0;
//#0 tt_fu_54 = 7'd0;
//#0 indvar_flatten_fu_58 = 15'd0;
end

HEAD_flow_control_loop_pipe flow_control_loop_pipe_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(real_start),
    .ap_ready(internal_ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int),
    .ap_continue(ap_continue)
);

HEAD_regslice_both #(
    .DataWidth( 32 ))
regslice_both_i_stream_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .data_in(i_stream_TDATA),
    .vld_in(i_stream_TVALID),
    .ack_in(regslice_both_i_stream_U_ack_in),
    .data_out(i_stream_TDATA_int_regslice),
    .vld_out(i_stream_TVALID_int_regslice),
    .ack_out(i_stream_TREADY_int_regslice),
    .apdone_blk(regslice_both_i_stream_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_pp0_stage0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter1 <= 1'b0;
    end else begin
        if ((1'b1 == ap_condition_exit_pp0_iter0_stage0)) begin
            ap_enable_reg_pp0_iter1 <= 1'b0;
        end else if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
            ap_enable_reg_pp0_iter1 <= ap_start_int;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_enable_reg_pp0_iter2 <= 1'b0;
    end else begin
        if ((1'b0 == ap_block_pp0_stage0_subdone)) begin
            ap_enable_reg_pp0_iter2 <= ap_enable_reg_pp0_iter1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        start_once_reg <= 1'b0;
    end else begin
        if (((real_start == 1'b1) & (internal_ap_ready == 1'b0))) begin
            start_once_reg <= 1'b1;
        end else if ((internal_ap_ready == 1'b1)) begin
            start_once_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_124)) begin
        if ((icmp_ln113_fu_129_p2 == 1'd0)) begin
            ciat_fu_50 <= ciat_3_fu_173_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            ciat_fu_50 <= 8'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_124)) begin
        if ((icmp_ln113_fu_129_p2 == 1'd0)) begin
            indvar_flatten_fu_58 <= add_ln113_fu_123_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            indvar_flatten_fu_58 <= 15'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_124)) begin
        if ((icmp_ln113_fu_129_p2 == 1'd0)) begin
            tt_fu_54 <= select_ln113_fu_153_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            tt_fu_54 <= 7'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        cmp6_reg_270 <= cmp6_fu_217_p2;
        select_ln113_reg_259 <= select_ln113_fu_153_p3;
        trunc_ln118_reg_264 <= trunc_ln118_fu_163_p1;
        trunc_ln118_reg_264_pp0_iter1_reg <= trunc_ln118_reg_264;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (icmp_ln113_fu_129_p2 == 1'd1) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_idle_pp0 == 1'b1) & (ap_start_int == 1'b0) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_enable_reg_pp0_iter2 == 1'b0) & (ap_enable_reg_pp0_iter1 == 1'b0) & (ap_enable_reg_pp0_iter0 == 1'b0))) begin
        ap_idle_pp0 = 1'b1;
    end else begin
        ap_idle_pp0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_subdone) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_ciat_2 = 8'd0;
    end else begin
        ap_sig_allocacmp_ciat_2 = ciat_fu_50;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_indvar_flatten_load = 15'd0;
    end else begin
        ap_sig_allocacmp_indvar_flatten_load = indvar_flatten_fu_58;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_tt_load = 7'd0;
    end else begin
        ap_sig_allocacmp_tt_load = tt_fu_54;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (cmp6_reg_270 == 1'd1) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cls_sm_blk_n = cls_sm_full_n;
    end else begin
        cls_sm_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (cmp6_reg_270 == 1'd1) & (ap_enable_reg_pp0_iter2 == 1'b1))) begin
        cls_sm_write = 1'b1;
    end else begin
        cls_sm_write = 1'b0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0) & (ap_done_reg == 1'b0) & (icmp_ln113_fu_129_p2 == 1'd0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        i_stream_TDATA_blk_n = i_stream_TVALID_int_regslice;
    end else begin
        i_stream_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp0_stage0_11001) & (icmp_ln113_fu_129_p2 == 1'd0) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0))) begin
        i_stream_TREADY_int_regslice = 1'b1;
    end else begin
        i_stream_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    if (((start_full_n == 1'b0) & (start_once_reg == 1'b0))) begin
        real_start = 1'b0;
    end else begin
        real_start = ap_start;
    end
end

always @ (*) begin
    if (((real_start == 1'b1) & (start_once_reg == 1'b0))) begin
        start_write = 1'b1;
    end else begin
        start_write = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_pp0_stage0 : begin
            ap_NS_fsm = ap_ST_fsm_pp0_stage0;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln113_fu_123_p2 = (ap_sig_allocacmp_indvar_flatten_load + 15'd1);

assign add_ln114_fu_167_p2 = (ap_sig_allocacmp_ciat_2 + 8'd1);

assign ap_CS_fsm_pp0_stage0 = ap_CS_fsm[32'd0];

assign ap_block_pp0_stage0 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_pp0_stage0_01001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_11001 = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_pp0_stage0_subdone = ((ap_done_reg == 1'b1) | ((ap_enable_reg_pp0_iter2 == 1'b1) & (1'b1 == ap_block_state3_pp0_stage0_iter2)) | ((ap_start_int == 1'b1) & (1'b1 == ap_block_state1_pp0_stage0_iter0)));
end

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_done_reg == 1'b1) | ((icmp_ln113_fu_129_p2 == 1'd0) & (i_stream_TVALID_int_regslice == 1'b0)));
end

always @ (*) begin
    ap_block_state3_pp0_stage0_iter2 = ((cmp6_reg_270 == 1'd1) & (cls_sm_full_n == 1'b0));
end

always @ (*) begin
    ap_condition_124 = ((1'b0 == ap_block_pp0_stage0_11001) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_pp0_stage0));
end

assign ap_enable_pp0 = (ap_idle_pp0 ^ 1'b1);

assign ap_enable_reg_pp0_iter0 = ap_start_int;

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_ready = internal_ap_ready;

assign ciat_3_fu_173_p3 = ((icmp_ln114_fu_147_p2[0:0] == 1'b1) ? 8'd1 : add_ln114_fu_167_p2);

assign cls_sm_din = trunc_ln118_reg_264_pp0_iter1_reg;

assign cmp6_fu_217_p2 = ((select_ln113_reg_259 == 7'd0) ? 1'b1 : 1'b0);

assign i_stream_TREADY = regslice_both_i_stream_U_ack_in;

assign icmp_ln113_fu_129_p2 = ((ap_sig_allocacmp_indvar_flatten_load == 15'd18816) ? 1'b1 : 1'b0);

assign icmp_ln114_fu_147_p2 = ((ap_sig_allocacmp_ciat_2 == 8'd192) ? 1'b1 : 1'b0);

assign select_ln113_fu_153_p3 = ((icmp_ln114_fu_147_p2[0:0] == 1'b1) ? tt_2_fu_141_p2 : ap_sig_allocacmp_tt_load);

assign start_out = real_start;

assign trunc_ln118_fu_163_p1 = i_stream_TDATA_int_regslice[12:0];

assign tt_2_fu_141_p2 = (ap_sig_allocacmp_tt_load + 7'd1);

endmodule //HEAD_select_cls
// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_start_for_do_adapt_1_U0
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 1,
    ADDR_WIDTH   = 1,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid?  no 
//------------------------Instantiation------------------
    HEAD_start_for_do_adapt_1_U0_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_start_for_do_adapt_1_U0_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 

endmodule  


module HEAD_start_for_do_adapt_1_U0_ShiftReg
#(parameter
    DATA_WIDTH  = 1,
    ADDR_WIDTH  = 1,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_start_for_do_layernorm_U0
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 1,
    ADDR_WIDTH   = 1,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid?  no 
//------------------------Instantiation------------------
    HEAD_start_for_do_layernorm_U0_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_start_for_do_layernorm_U0_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 

endmodule  


module HEAD_start_for_do_layernorm_U0_ShiftReg
#(parameter
    DATA_WIDTH  = 1,
    ADDR_WIDTH  = 1,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_start_for_do_matmul_U0
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 1,
    ADDR_WIDTH   = 1,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid?  no 
//------------------------Instantiation------------------
    HEAD_start_for_do_matmul_U0_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_start_for_do_matmul_U0_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 

endmodule  


module HEAD_start_for_do_matmul_U0_ShiftReg
#(parameter
    DATA_WIDTH  = 1,
    ADDR_WIDTH  = 1,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_start_for_matmul_step1_cache_window_U0
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 1,
    ADDR_WIDTH   = 1,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid?  no 
//------------------------Instantiation------------------
    HEAD_start_for_matmul_step1_cache_window_U0_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_start_for_matmul_step1_cache_window_U0_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 

endmodule  


module HEAD_start_for_matmul_step1_cache_window_U0_ShiftReg
#(parameter
    DATA_WIDTH  = 1,
    ADDR_WIDTH  = 1,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule// ==============================================================
// Generated by Vitis HLS v2023.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

`timescale 1ns/1ps
//RAW latency 1 

module HEAD_start_for_matmul_step2_mac_U0
#(parameter
    MEM_STYLE    = "shiftReg",
    DATA_WIDTH   = 1,
    ADDR_WIDTH   = 1,
    DEPTH        = 2)
(
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,
    
    // read 

    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Parameter----------------------

//------------------------Local signal-------------------
    wire [ADDR_WIDTH-1:0] addr;
    wire                  push;
    wire                  pop;
    reg signed [ADDR_WIDTH:0] mOutPtr;
    reg                   empty_n = 1'b0;
    reg                   full_n = 1'b1; 
    // has num_data_valid?  no 
//------------------------Instantiation------------------
    HEAD_start_for_matmul_step2_mac_U0_ShiftReg 
    #(  .DATA_WIDTH (DATA_WIDTH),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DEPTH      (DEPTH))
    U_HEAD_start_for_matmul_step2_mac_U0_ShiftReg (
        .clk        (clk),
        .we         (push),
        .addr       (addr),
        .din        (if_din),
        .dout       (if_dout)
    );
//------------------------Task and function--------------

//------------------------Body---------------------------
    // num_data_valid 

    // almost full/empty 

    // program full/empty 

    assign if_full_n  = full_n; 
    assign if_empty_n = empty_n;

    assign push       = full_n & if_write_ce & if_write;
    assign pop        = empty_n & if_read_ce & if_read;

    assign addr       = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0] : {ADDR_WIDTH{1'b0}};

    // mOutPtr
    always @(posedge clk) begin
        if (reset)
            mOutPtr <= {ADDR_WIDTH+1{1'b1}};
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset)
            full_n <= 1'b1;
        else if ((push & ~pop) && (mOutPtr == DEPTH - 2))
            full_n <= 1'b0;
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if ((~push & pop) && (mOutPtr == 0))
            empty_n <= 1'b0;
    end

    // almost_full_n 

    // almost_empty_n 

    // prog_full_n 
 
    // prog_empty_n 

    // num_data_valid 

endmodule  


module HEAD_start_for_matmul_step2_mac_U0_ShiftReg
#(parameter
    DATA_WIDTH  = 1,
    ADDR_WIDTH  = 1,
    DEPTH       = 2)
(
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] din,
    output wire [DATA_WIDTH-1:0] dout
);

    reg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
    integer i;

    always @ (posedge clk) begin
        if (we) begin
            for (i=0; i<DEPTH-1; i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= din;
        end
    end

    assign dout = SRL_SIG[addr];

endmodule